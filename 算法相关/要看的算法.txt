1.贪婪算法-0/1背包问题
1）糖果问题（easy,leetcode.455）
2)摇摆序列（medium，leetcode.376）：状态机（分析变换状态）
3）移除K个数字（medium，leetcode.402）：贪心+栈（vector）；
4-a)跳跃游戏（medium，leetcode.55）
4-b)最少跳跃几次能到达
5)射击气球（medium,leetcode.452）
6）最优加油法（Hard）

2.递归、回溯、分而治之
（一）递归：递归基、递归过程；
（二）回溯：试探、但当探索到某一步时，发现原先选择达不到目标，就退回一步重新选择；
1-a）求无重复元素的子集（leetcode.78，medium）(回溯法、位运算法 )
1-b)求有重复元素的子集（leetcode.90，medium）
1-c)求子集元素之和为目标值（leetcode39、40，medium）(如果利用前两种法，时间复杂度过高（O(2^n)）):可以利用减枝；1
1-d）求子集元素之和为目标值（leetcode39，medium）：利用for循环遍历求解；
2）生成括弧（leetcode.22，Medium）（寻找对的关键）
3)N皇后问题（leetcode.51 Hard）（利用两个矩阵计数和位置）
(三)分治法
（1）归并排序（首先写出归并的过程，然后递归调用）（O(nlogn)）
4)逆序数（leetcode.315，Hard）（要用nlgn算法，归并两个数组的时候，后面数组的指针位置为前面的逆序数，改造归并排序）




3.动态规划(暴力搜索、记忆性递归搜索，找出冗余过程、动态规划)
原问题、子问题、动态规划状态、边界状态、状态转移方程
1）爬楼梯（leetcode.70，easy）
状态转移方程：dp[i]=dp[i-1]+dp[i-2];
2)打家劫舍（leetcode.198，easy）
状态转移方程：nums[i-1]+dp[i]>dp[i-1];dp[i]=dp[i-2]+nums[i-1] else dp[i]=dp[i-1];
3）最大子段和（leetcode.53，easy）
状态转移方程：dp[i-1]<0,dp[i]=nums[i];dp[i]=dp[i-1]+num[i];
4）找零钱（leetcode.322，medium）
状态转移方程：if(i-coins[j]>=0&&dp[i-coins[j]]！=-1){if（dp[i]==-1&&dp[i]>dp[i-coins[j]]+1）dp[i]=dp[i-coins[j]]+1;
5）三角形（leetcode.120，medium）
状态转移方程：从下往上利用vector求值				
6）最长上升子序列（leetcode.300，medium）
状态转移方程：两层循环寻找比其大的最长子序列；(n^2)
还可以另外一种栈方法，时间复杂度更低：利用栈为该长度的最小元素+1的序列的最小元素；(nlog(n))
7）最小路径和（leetcode.64，medium）
转移方程：从上往下递归，寻找递归式；
8）地牢游戏（leetcode.174，hard）
转移方程：从下往上递归，寻找递归式子；
9）背包问题（dp[x][y]=max(dp[x-1][y],dp[x-1][y-w[x]]+v[x])）
10)给定两个字符串str1,str2，在给定三个整数ic,dc,rc(代表插入、删除、替换)的代价，返回将str1编辑为str2的最小代价（首先生成（m+1）*(n+1)的矩阵大小，dp[i][j]表示str1[0...i-1]编辑成str2[0...j-1]的最小代价）
dp[i][j]来源于四种情况：1:dc+dp[i-1][j] 2:ic+dp[i][j-1] 3:dp[i-1][i-1]+rc 4:dp[i-1][j-1]
10）最长回文子序列（a[i][j]:lps(i,j)最长子序列，在（i，j）中判断， 第j个和第i个关系：if（s[i]==s[j]）dp[i][j]=d[i+1][j-1]+2,否则dp[i][j]=max(dp[i+1][j],dp[i][j-1]））


4.链表
1）.链表逆序（leetcode.206，medium）
2）.链表逆序（leetcode.92，medium）（升级版）
3）.求两个链表交点（160，easy）1:利用set的find;  2:计算链表长度获取；
4）链表求环（141,142，medium）1:利用set;2:快慢指针思想（先找到相遇点，再找到起始点）
5）链表划分（86，medium）:巧用临时头节点
6）复杂的链表的深度拷贝（138，hard）
7)合并两个有序链表（21，easy）
8)多个链表合并（23，hard）(1.暴力法，2.利用vector排序，3.分治，归并)


5.栈、堆、队列
栈：stack头文件，基于底层的deque（默认的）、vector、list都可以实现；有top、empty、push、pop、size等5个成员函数；
队列：queue头文件，基于底层的deque（默认的）、list都可以实现；有empty、front、back、pop、push、size等6个成员函数；
1）使用队列实现栈（leetcode 225，Easy）(主要是push，两个队列)
2)使用栈实现队列（232，EAsy）(主要是push，两个栈)
3)包含min函数的栈（155，easy）(两个栈实现)
4）栈出序列判断合法性（poj）(栈+队列)
5）简单的计算器（224，hard）(两个栈：数字栈和符号栈)
堆：(优先输出系列）priority queue头文件,利用vector实现，有empty、pop、push、top、size等5个成员函数；最大堆（默认），
最小堆（priority_queue<int,vector<int>,greater<int>）;
6）数组中的第K大的数（215，easy）(利用堆来实现)
7)寻找中位数（295，hard）（堆或二叉树来解决）


6.二叉树与图
二叉树：一个节点三个指针（父指针(可能没有)、左右节点）；三种遍历（前（根左右）、中（左跟右）、后（左右根））=》深度搜索；
1）路径之和（113，medium)（深度搜索）
2）最近的公共祖先（236，medium）（本质也是深度搜索，遍历其两天路径，找其最后一个公共点）
3）二叉树转链表（114，medium）(1)利用vector,2就地转换：递归左右子树实现)
二叉数宽度优先遍历：按层访问节点；使用队列存储节点；进行搜索；
4）侧面观察二叉树（199，medium）（求层次遍历二叉树的最后一个节点）
图：无向图和有向图，图的表示方法：邻接矩阵（稠密图）、邻接表（稀疏图）；图的深度优先遍历：先访问一个顶点，访问邻接顶点，继续访问下一个节点
的邻接点；图的广度优先遍历：先访问完所有顶点的邻接点，在继续下一次。
5）课程安排（207，medium)：（如果有向连通图无环，1.深度搜索，三种状态，2.广度搜索：根据入度）


7.二叉查找与二叉排序树
二分查找：折半查找
1）插入位置（35，easy）（查找加限制）
2)区间查找（34，medium）（左端点、右端点限制查找）
3)旋转数组查找（33 ,meidium）(旋转情况判断，目标与中点，起始与目标等)
二叉排序树：若左子树非空，在左子树上所有节点的值均小于等于它的根节点；若右子树不空，则右子树上所有节点的值均大于或等于它的根节点；左右子树
也为二叉排序树，等于的情况只能出现在左子树或右子树中的某一侧；
中序遍历二叉查找树其实就是从小到大排序；可以通过递归实现二叉树的插入；同理二叉树查找也可以通过递归查找实现；
4）二叉查找树编码与解码（449，medium）（利用前序遍历解析复原）
5）逆序数（315，hard）(原数组逆转后的顺序插入到二叉排序查找树中，找到个数，逆转归还；前面还有一种归并排序)


8.哈希表与字符串
哈希表：（也叫散列表），根据关键字值直接进行数据结果；简单哈希构造：哈希统计、哈希排序（利用数组存储）；复杂哈希构造：利用哈希函数，将关键
字值（KEY）转换为整数再对表长取余，从而关键值被转换为哈希表的表长范围内。拉链法解决冲突；（哈希表表长取质数，冲突会少一点）
1）最长回文串（409，easy);(数量)
2)词语模式（290，easy）（拆解对应）
3）同字符词语分组（49，medium）(利用map找对关系映射即可)
4）无重复字符的最长字串(必须连续，不连续叫子序列)（3，medium）（利用双指针滑动法）
5）求重复的DNA序列（187，medium）(1.暴力插入map;2.利用整数映射，设置全局，可以防止栈溢出)
6）最小窗口字串（76，hard）(利用双指针，)


9.搜索
1)岛屿数量（200，medium）(宽搜、深搜)：DFS:利用mark组标记进行，未进行回溯，深度搜索就是递归；BFS:利用循环push队列；
2-a)词语阶梯(127,medium)（哈希、搜索、图等）：图的宽度优先搜索，求最短，单词为点，转换为边；采用邻接表，map构造，由于关键字为string；
2-b)词语阶梯（126，Hard）(1.建图的问题：包不包含起始点，2：如何保存搜索的点。3：如何搜索所有可能的路径)答2：利用vector代替队列去实现；在队列节点
中增加前驱在队列中的位置；答3：记录最短路径，后面如果也满足，也将其放进去；1答：先判断一下就OK
3)火材棍摆正方形（473，medium）(深搜回溯)直接深度优化搜索，超时，优化剪枝：1.对n个火柴的总和对4取余是否为0；2.火柴杆按照从大到小的顺序排列
减少回溯的可能；3.每次放置时，不可放置超过总和的1/4长的火柴；另一种位运算法：通过位运算的并和或来判断；
4)收集雨水（leetcode.407,hard）（由里到外，利用广度优先，堆来进行）


10.复杂数据结构
trie树（字典树）：关键字不是直接保存在节点中，而是由节点在树中的位置决定，一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串。使用
公共前缀来减少存储空间与查询时间，从而最大限度地减少字符串比较。trie树的节点有存储孩子节点的数组（大小为最大情况，例如26个字母），是否是尾节
点，插入、搜索、遍历，是否有相同前缀；
1)实现trie树（208，medium）(判断插入、搜寻、某个前缀)
2）添加与查找单词（211，medium）（主要分析查找，利用递归）
3)朋友圈（547，medium）(1.深搜，2并查集)
并查集：应用于N个元素的集合求并与查询问题，在该应用场景中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按照一定顺序将属于同一组的
元素所在的集合合并，其间要反复查找一个元素在哪个集合中。由于时间复杂度关系，采用森林实现，本质也是数组，只是表现为森林。
4）区域和的查询（307，medium）(线段树：完全二叉树（平衡二叉搜索树）)
线段树：它将一个线段区间划分成一些单元区间。对于线段树中的每一个非叶子节点[a,b]，它的左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2+1,b]
,最后的叶子节点数目为N,与数组下标对应。线段树的一般包括建立、查询、插入、更新等操作，建立规模为N的时间复杂度时O(NlogN)，其他操作时间复杂度为
O(logN)。完全二叉树可以利用数组来保存，左孩子为2*i+1,有孩子为2*i+2;根节点下标为0；



11.位运算
1）布隆过滤器:不安全网页的黑名单包含100亿个黑名单网页，每个网页的url最多占用64字节。要实现一种网页过滤系统，可以根据网页url
判断网页是否是在黑名单；请设计该系统，要求该系统允许有万分之一的判断失误率，并且使用的额外空间不要求超过30G;()
不浓过滤器大小确定（m）：m=-(n*lnp)/(ln2)^2;计算哈希函数的个数：k=ln2*（m/n）;真实失误率：（1-e^(nk/m)）^k；
常规方法：首先注意到题目有一定的失误率；然后求出过滤器大小；根据大小计算哈希函数个数；最后可以求得真实 的失误率；
2）如何不用额外的变量交换两个整数值（a=a^b;b=a^b;a=a^b）;
3)给定两个32位的整数，不使用比较符合比较两个数的大小（1.得到a-b的符号，判断最高位）
4）给定一个整形数组找出奇数次出现的那个数（利用异或运算满足交换律和结合律）
5）如果有两个数出现奇数，其他都为偶数（还是按照异或法，将首次异或的结构保存下来；然后再找其中的一个1位记录下来，与原数组中该位置位1的进行异或，就能找到第一个，然后在异或之前那个，就找到第一个）
6）设置一种加密过程（异或）
7）从奇数树中找出现偶数次的数（leetcode）



12.补充问题
1）加油问题
从start出发， 如果油量足够， 可以一直向后走 end++；  油量不够的时候，
start向后退  最终 start == end的时候，如果有解一定是当前 start所在位置
class Solution {
public:
 int canCompleteCircuit(vector<int> &gas, vector<int> &cost) 
{
int start = gas.size() - 1;
int end = 0;
int sum = gas[start] - cost[start];
while(start > end){
if(sum >= 0){
sum += gas[end] - cost[end];
++end;
}else{
--start;
sum += gas[start] - cost[start];
}
}
return sum >=0 ? start : -1;
}
};















