第一章 Linux简介
1.Linux内核与传统的Unix系统至今存在一些显著差异：
1）Linux支持动态加载内核模块
2）Linux支持对称多处理机制
3）Linux内核可以抢占
4）Linux对线程支持的实现比较有意思：内核不区分线程和其他的一般进程。对于内核来说，所有的进程都一样--只不过其中的一些共享资源
5）Linux提供具有设备类的面向对象的设备模型、热插拔事件，以及用户空间的设置文件系统
6）Linux忽略了一些被认为是设计得很拙劣的UNIx特性
7）Linux体现了自由这个词的精髓。
2.Linux通过一个简单的命名机制来区分稳定的和处于开发中的内核：
使用三个或者四个用“.”分隔的数字来代表不同内核版本。第一个数字是主版本号，第二个数字是从版本号，第三个数字是修订版本号，
第四个可选的数字为稳定版本号。从副版本号可以反应出该内核是一个稳定版本还是一个处于开发中的版本：该数字如果是偶数，那么为
稳定版本，如果是奇数，那么为开发版。
第二章 从内核出发
1.内核开发的特点：
1）内核编程时既不能访问C库也不能访问标准的C头文件
2）内核编程时必须使用GNU C
3）内核编程时缺乏像用户空间那样的内存保护机制
4）内核编程时难以执行浮点运算
5）内核给每一个进程只有一个很小的定长堆栈
6）内核支持异步中断、抢占和SMP，因此必须时刻注意同步和并发。
7）要考虑可移植性的重要性。
2.内联函数：
内核编程中优先使用内敛函数而不是复杂的宏，定义一个内联函数需要使用static作为关键字，会使得编译时不会为内敛函数单独
创建一个函数体。
3.内敛汇编：gcc编译器支持在C函数中嵌入汇编指令。常用asm()指令潜入汇编代码。
第三章 进程管理
1.进程描述符及任务结构
   内核把进程的列表存放在叫做任务队列的双向循环链表中。链表中每一项都是类型为task_struct、成为进程描述符的结构。定义在
<linux/sched.h>文件中。进程描述符包含一个具体进程的所有信息。包括打开的文件、进程空间地址、挂起的信息、进程的状态等。
2.Linux通过slab分配器分配task_struct结构，在栈底或栈顶创建一个struct thread_info,结构中task域指向任务实际task_struct的指针。
3.内核通过一个唯一的进程标识值或PID（实际为int）来标识每个进程,默认为32768（short int的最大值）,可以根据/proc/sys/kernel/pid_max提高上限值
4.进程描述符中state描述5个状态：TASK_RUNNING(运行)、TASK_INTERRUPTIBLE（可中断）、TASK_UNINTERRUPTIBLE(不可中断)、_TASK_TRACED（被其他进程跟踪的进程）、_TASK_STOPPED(停止)；
5.设置进程状态函数：
<linux/sched.h>
set_task_state(task,state);
6.所有的进程都是PID为1的init进程的后代。内核在系统启动的最后阶段启动init进程。该进程读取系统的初始化脚本并执行其他的相关程序，最终完成系统启动的整个过程。
7.进程创建，主要利用fork()（调用clone()系统调用）、exec()；子进程和父进程的区别仅仅在于PID、PPID和某些资源和统计量（例如，挂起的信号）
8.Linux的fork()使用写时拷贝页实现。写时拷贝是一种推迟甚至免除拷贝数据的技术，内核此时并不复制整个进程地址空间，而是
让父进程和子进程共享同一个拷贝。只有在需要写入的时候，数据才会复制，从而使各个进程拥有各自的拷贝。
9.clone()调用do_fork(),do_fork()完成了创建中的大部分工作，定义在kernel/fork.c文件中。该函数调用copy_process()函数，然后让进程
开始运行。
10.vfork()除了不拷贝父进程的页表项外，其他和fork()的功能相同。
10.Linux实现线程的机制非常独特，内核没有准备特别的调度算法或是定义特别的数据结构来表征线程。相反，线程仅仅被视为一个与
其他进程共享某些资源的进程。每一个线程都拥有唯一隶属于自己的task_struct，所以在内核中，它看起来像是一个普通的进程。
11.进程终结依靠do_exit(),调用后处于僵尸态，但是保留了它的进程描述符。让系统有办法在子进程终结后仍能获得它的信息。利用
父进程的wait函数，调用wait4()系统调用实现。调用release_task()调用完成删除。
12.对于孤儿进程，子进程在当前线程组内找一个线程作为父亲，如果不行，就让init做它们的父进程。在do_exit()中会调用exit_notify()，
该函数会调用forget_original_parent()，而后者会调用find_new_reaper()来执行寻父过程。
第四章 进程调度
1.Linux采用了两种不同的优先级范围，第一种是用nice值，它的范围是从-20到+19，默认值为0；越大的nice值意味着更低的优先级
第二种是实时优先级，其值是可配置的，默认情况下它的变化范围是从0到99，越高的实时优先级数值意味着进程优先级越高。
查看实时优先级 ps -eo state,uid,pid,ppid,rtprio(实时),time,comm.
2.时间片是一个数值，表明进程在被抢占前所能持续运行的时间。一般默认10ms
3.完成公平调度（CFS）是一个针对普通进程的调度类。
4.CFS的出发点基于一个简单的理念：进程调度的效果应如同系统具备一个理想中的完美多任务处理器。在这种系统中，每个进程将能
获得1/n的处理器时间---n是指可运行进程的数量。CFS允许每个进程进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程，而不再采用分配给每个进程时间片的做法了。
CFS在所有可运行进程总数基础上计算出一个进程应该运行多久，而不是依靠nice值来计算时间片。nice值在CFS中被作为进程获得的处理器运行比的权重。最小粒度为1ms。
5.Linux调度实现：时间记账、进程选择、调度器入口、睡眠和唤醒
1）时间记账
CFS不再有时间片的概念，为了需要确保每个进程只在公平分配给它的处理器时间内运行。CFS使用调度器实体结构来追踪进程运行记账。
调度器实体结构嵌入再进程描述符struct task_struct内；调度器实体结构使用vruntime变量记录一个程序到底运行了多长时间以及它
还应该再运行多久。
2）进程选择
当CFS需要选择下一个运行进程时，它会挑一个具有最小vruntime的进程。利用红黑树组织可运行进程队列，并利用其迅速找到最小vruntime
值的进程。运行rbtree树中最左边叶子节点所代表的那个进程
3）调度器入口
主要是函数schedule()函数：找到最高优先级的调度类，后者需要有自己的可运行的队列，然后询问谁才是下一个该运行的进程。
4）睡眠和唤醒
进程把自己标记成休眠状态，从可执行红黑树中移出，放入等待队列，然后调用schedule()选择和执行一个其他进程。唤醒相反，进程被设置为
可执行状态，然后再从等待队列中移到可执行红黑树中。
6.等待队列
休眠通过等待队列进行处理。等待队列是由等待某些事件发送的进程组成的简单链表，进程通过执行下面几个步骤将自己加入到一个等待队列中：
1）调用宏DEFINE_WAIT()创建一个等待队列的项
2）调用add_wait_queue()把自己加入到队列中。
3）调用prepare_to_wait()方法将进程的状态更为TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE。
4）如果状态被设置为TASK_INTERRUPTIBLE，则信号唤醒进程。
5）当进行被唤醒的时候，它会再次检查条件是否为真。
6）当条件满足后，进程将自己设置为TASK_RUNNING并调用finish_wait()方法把自己移出等待队列。
7.唤醒
唤醒操作通过函数wake_up()进行，它会唤醒指定的等待队列上的所有进程。
8上下文切换
从一个可执行进程切换到另一个可执行进程。由content_switch函数负责。当一个新的进程被选出来准备投入运行的时候，schedule()就
会调用该函数，完成两项基本工作：
1）调用switch_mm(),该函数负责把虚拟内存从上一个进程映射切换到新进程中，switch_to()，该函数负责从上一个进程的处理器状态
切换到新进程的处理器状态。包括保存、恢复栈信息和寄存器信息，还有其他任何于体系结构相关的状态信息，都必须以每个进程为对象
进行管理和保存。
9.内核提供一个need_resched标志来表明是否需要重新执行一次调度。
10.用户抢占发生在：一、从系统调用返回用户空间；二、从中断处理程序返回用户空间时。
11.内核抢占会发生在：一、中断处理程序正在执行，且返回内核空间之前（计数为0，且need_resched被设置）；二、内核代码再一次具有可抢占性的时候；三、如果内核
中的任务显示地调用scheeule()；四、如果内核中的任务阻塞（这样也会导致调用schedule()）。
10.两种实时调度策略：SCHED_FIFO和SCHED_RR。而普通的、非实时的调度策略时SCHED_NORMAL。三者借助调度类的框架，这些实时策略
并不被完全公平调度器来管理，而是被一个特殊的实时调度器管理。
11.SCHED_FIFO实现一直简单的、先入先出的调度算法：不使用时间片。处于可运行状态的SCHED_FIFO级的进程会比任何SCHED_NORMAL级
的进程都先得到调度。一旦一个SCHED_FIFO级进程处于可执行状态，就会一直执行，直到自己受阻或显示释放处理器为止。只有更高
优先级的SCHED_FIFO或者SCHED_RR任务才能抢占SCHED_FIFO任务。如果有相同的SCHED_FIFO级进程，则轮流处理。只要有SCHED_FIFO
级进程在执行，其他级别较低的进程只能等待它变为不可运行态才会有机会执行。
12.SCHED_RR与SCHED_FIFO大体相同，只是SCHED_RR级的进程在耗尽事先分配给它的时间后就不能再继续执行了。
13.上述两种实时算法实现的都是静态优先级。内核不为实时进程计算动态优先级。保证优先级别的实时进程总能抢占优先级比它低的进程。
14.Linux的实时调度算法提供一种软实时工作方式，内核调度进程，尽力使进程再它的限定时间到来前运行，但内核不保证总能满足
这些进程的要求。相反，硬实时系统保证再一定条件下，可以满足任何调度的要求。

第五章 系统调用
1.系统调用在用户空间进程和硬件设备之间添加了一个中间层。主要三个作用：一是为用户空间提供了一种硬件的抽象接口；二是保证系统
的稳定和安全；三是出于对虚拟系统的考虑
2.系统调用在出现错误的时候C库会把错误码写入errno全局变量。通过调用perror()库函数，可以把该变量翻译成用户可以理解的错误字符串
3.在Linux中，每个系统调用被赋予一个系统调用号。用来指定到底是要执行哪个系统调用；进程不会提及系统调用的名称。系统调用号存在系统调用表中；
4.通知内核的机制是靠软中断实现：通过引发一个异常来促使系统切换到内核态去执行异常处理程序（实际上就是系统调用处理程序）。
5.x86系统上预定义的软中断号为128，通过int $0x80指令触发该中断。
6.当编写完一个系统调用后，把它注册一个正式的系统调用：
1）首先，在系统调用表的最后加入一个表项（entry.s文件中）；
2）对于所支持的各种体系结构，系统调用号都必须定义于<asm/unistd.h>中；
3）系统调用必须被编译进内核映像。这只要把它放进kernel/下的一个相关文件（如sys.c）

第六章 内核数据结构
1.主要涉及链表、队列、映射、二叉树；
2.linux内核中链表实现不是将数据结构塞入链表，而是将链表节点塞入数据结构。
3.链表声明在<linux/list.h>中
struct list_head{
	struct list_head *next;
	struct list_head *prev;
	}
利用list_entry返回包含list_head的父类型结构体
LIST_HEAD_INIT()初始化一个指针
static LIST_HEAD(类对象)：返回链表头指针
4.生成者和消费者模型：队列，头文件<linux/kfifo.h>；
5.映射，关联数组，一个由唯一键组成的集合，而每个键必然关联一个特定的值。

第七章 中断和中断处理
1.中断使得硬件得以发出通知给处理器。不同的设备对应的中断不同，而每个中断都通过一个唯一的数字标志，中断值通常被称为中断
请求线。
2.因为又想中断处理程序运行得快，又想中断处理程序完成得工作量多，将中断处理程序分为上部分和下部分，上部分立即执行，但只
做有严格时限得工作，例如中断进行应答或复位硬件。能够被允许稍后完成的工作会推迟到下半部去，此后，合适的时机，下半部分
会被中断开执行。
3.<linux/interrupt.h>中request_irq函数注册一个中断处理程序：
int request_irq(unsigned int irq,irq_handler_t handler,unsigned long flags,const char *name,void *dev)
第一个参数irq表示要分配的中断号，第二个参数handler是一个指针，指向处理这个中断的实际中断处理程序，第三个参数是中断处理
程序标志，可以为0，也可以是下列一个或多个标志的位掩码：
1）IRQF_DISABLED：该标志被设置后，意味着内核在处理中断处理程序本身期间，要禁止所有的其他中断
2）IRQF_SAMPLE_RANDOM：此标志表明这个设备产生的中断对内核熵池有贡献
3）IRQF_TIMER:该标志是特别为系统定时器的中断处理而准备的
4）IRQF_SHARED:此标志表明可以在多个中断处理程序之间共享中断线。
第四个参数name是于中断相关的设置的ASCII文本表示。
第五个参数dev用于共享中断线。
4.卸载驱动程序，需要注销相应的中断处理程序，释放中断线。
void free_irq(unsigned int irq,void *dev)

第八章 下半部和推后执行的工作
1.建议放在上部分的情形：
1）如果一个任务对时间非常敏感，将其放在中断处理程序中执行
2）如果一个任务和硬件相关，将其放在中断处理程序中执行
3）如果一个要求保证不被其他中断（特别是相同中断）打断，将其放在中断处理程序中执行。
其他任务，考虑放置在下半部分。
2.三种机制可以实现将工作推后执行：软中断，tasklet（软中断实现，常用）和工作队列。
3.软中断最多可能有32个中断，静态编译，一个软中断不会抢占另外一个软中断。实际上，唯一可以抢占软中断的是中断处理程序。
主要用于网络和SCSI直接使用软中断。
下列地方，待处理的软中断会被检查和执行：
1）从一个硬件中断代码出返回时；
2）在ksoftirqd内核线程中；
3）在那些显示检查和执行待处理的软中断的代码中，如网络子系统
4.tasklet通过软中断实现，动态绑定，有两类：HI_SOFTIRO和TAKSLET_SOFTIRQ，唯一区别在于，前者优于后者。
5.工作队列是另外一种将工作推后执行的形式，交由一个内核线程，允许重新调度甚至是睡眠

第九章 内核同步介绍
1.临界区：访问和操作共享数据的代码段
2.内核中可能造成并发执行的原因：
	1）中断
	2）软中断和tasklet
	3）内核抢占
	4）睡眠及与用户空间的同步
	5）对称多处理
3.死锁：
	1）四个条件：互斥、不可剥夺、请求和保持、循环等待
4.锁的争用：当锁正在被占用时，有其他线程试图获得该锁

第十章 内核同步方法
1.原子操作:保证指令以原子的方式执行，执行过程不被打断。
2.内核中提供两种原子操作：原子整数操作（atomic_t，24位，低8位为嵌入的锁）、原子位操作
3.自旋锁：最多只能被一个可执行线程持有。任意时间，自旋锁都可以防止多与一个的执行线程同时进入临界区
	1）初衷：短期间内进行轻量级加锁
4.信号量：一种睡眠锁，持有自旋锁不允许睡眠
5.互斥体：互斥锁，信号量计数为1，可以睡眠的自旋锁
	1）任何时刻只有一个任务可以持有mutex
	2）必须在同一上下文中上锁和解锁
	3）递归地上锁和解锁是不允许的
	4）当持有一个mutex时，进程不可以退出
6.自旋锁和互斥体区别
	需求                      建议的加锁方法
低开销加锁                    优先使用自旋锁
短期锁定                      优先使用自旋锁
长期加锁                      优先使用互斥体
中断上下文中加锁              使用自旋锁
持有锁需要睡眠                使用互斥体
7.内存屏障：让CPU或编译器在内存访问上有序----发生在两个阶段：第一个编译时，编译器优化导致内存乱序访问（指令重排）、第二个运行时多 CPU 间交互引起内存乱序访问
	因此，有两种屏障编译器 barrier、CPU Memory barrier；其中编译乱序可以利用volatile
	1）通用屏障，保证读写操作有序的，mb()和smp_mb();
	2）写操作屏障，仅保证写操作有序，wmb()和smp_wmb();
	3）读操作屏障，仅保证读操作有序的，rmb()和smp_rmb();
	4）优化屏障，用于限制编译器的指令重排，不区分读写。
	内核实现的无锁环形缓冲区kfifo使用了内存屏障

第十一章 定时器和时间管理
1.i386体系结构中时钟中断频率就设定为100HZ
2.jiffies用来记录自系统启动以来产生的节拍的总数，无符号长整型
3.硬时钟：实时时钟，持久存放系统时间的设备，依靠主板上的微型电池提供的电力保持系统的计时，内核通过读取RTC来初始化墙上时间，存放在xtime变量中
4.系统定时器，提供一种周期性触发中断机制

第十二章 内存管理
1.内核把物理页做为内存管理单元的基本单位（32位4KB的页，而64位体系结构支持8KB的页）
2.内核用struct page结构表示系统中的每个物理页
3.伙伴分配器：将内存按2的幂进行划分，相当于分离出若干个块大小一致的空闲链表，搜索该链表并给出同需求最佳匹配的大小。其优点是快速搜索合并（O(logN)
时间复杂度）以及低外部碎片（最佳适配best-fit）；其缺点是内部碎片，因为按2的幂划分块，如果碰上66单位大小，那么必须划分128单位大小的块。但若需求本
身就按2的幂分配，比如可以先分配若干个内存池，在其基础上进一步细分就很有吸引力了。
    分配器的整体思想是，通过一个数组形式的完全二叉树来监控管理内存，二叉树的节点用于标记相应内存块的使用状态，高层节点对应大的块，低层节点对应小的块，
在分配和释放中我们就通过这些节点的标记属性来进行块的分离合并。
4.slab分配器：slab是Linux操作系统的一种内存分配机制。其工作是针对一些经常分配并释放的对象，如进程描述符等，这些对象的大小一般比较小，如果直接采用伙伴
系统来进行分配和释放，不仅会造成大量的内存碎片，而且处理速度也太慢。而slab分配器是基于对象进行管理的，相同类型的对象归为一类(如进程描述符就是一类)，
每当要申请这样一个对象，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统，
从而避免这些内碎片。slab分配器并不丢弃已分配的对象，而是释放并把它们保存在内存中。当以后又要请求新的对象时，就可以从内存直接获取而不用重复初始化。
基于高速缓存器上
5.每个进程都有两页的内核栈，32位8KB，64位16KB
6.中断栈为每个进程提供一个用于中断处理程序的栈，有了这个选项，中断处理程序不用再和被中断进程共享一个内核栈
7.kmalloc()函数确保页在物理地址上是连续的（虚拟地址自然也是连续），适用于连续的物理页
8.vmalloc()函数确保内存虚拟地址是连续的，而物理地址无须连续。适用于仅仅需要虚拟地址上连续的页
9.alloc_pages()函数进行高端内存分配，通过struct page结构的指针

第十三章 虚拟文件系统（VFS）：提供文件和文件系统相关的接口
1.Unix使用乐儿四种和文件系统相关的传统概念：文件、目录项、索引节点（inode）和安装点
2.VFS对象及其数据结构：
	超级块对象：代表一个具体的已安装文件系统
	索引节点对象:代表一个具体文件
	目录项对象：代表一个目录项，是路径的一个组成部分
	文件对象：代表由进程打开的文件
3.超级块对象：用于存储特定文件系统的信息，通常对应于存放在磁盘特定扇区中的文件系统超级块或者文件系统控制块。由super_block结构体表示
4.超级块操作：超级块对象中的s_op域，它指向超级块的操作函数表。由super_operrtions结构体表示。
5.索引节点对象：包含了内核在操作文件或目录时需要的全部信息，由inode结构体表示
6.索引点操作：和超级块一样，由索引点对象中的inode_operations项指明，由inode_operations结构体定义出来。
7.目录项对象：方便查找，目录项由dentry结构体表示。目录项对象有三种有效状态：被使用、未被使用和负状态
8.目录项缓存：主要包含三个部分：“被使用的”目录项链表、“最近被使用的”双向链表、散列表
9.目录项操作由dentry——operation结构体指明
10.文件对象：表示进程已打开的文件，由file结构体表示
11.文件操作：由file_operations结构体表示
12.和文件系统相关的数据结构：
	第一个对象是file_system_type,用来描述各种特定文件系统类型，例如ext3、ext4（本地文件系统）或NFS、Coda网络文件系统等。
	第二个结构体是vfsmount,用来描述一个安装文件系统的实例，一个安装点
13.和进程相关的数据结构
	第一个file_struct，该结构体由进程描述符中的files目录项指向。
	第二个fs_struct。该结构体由进程描述符的fs域指向
	第三个是namespace，使得每一个进程在系统中看到唯一的安装文件系统
	
第十四章 块I/O层
1.快设备：系统中能够随机访问固定大小数据片的硬件设备称作块设备，这些固定大小的数据片就称作块。
2.最常见的块设备是硬盘，以安装文件系统的方式使用的；另一种基本设备是字符设备，按照字符流的方式被有序访问，像串口和键盘就属于字符设备。区别在于是否可以随机访问数据
3.块设备中最小可寻址单元是扇区（一般为512K），要求块大小是2的倍数，并且要小于页面，因此块大小是512字节、1KB或4KB
4.缓冲区：当一个块被调入内存时，它要存储在一个缓冲区中。
5.缓冲区头：buffer_head包含了内核操作缓存区所需要的全部信息。目的在于描述磁盘块和物理内存缓冲区之间的映射关系。
	两个弊端
		1）缓冲区头是一个很大且不易控制的数据结构体，而且缓冲区头对数据的操作既不方便也不清晰。
		2）仅能描述单个缓冲区，当作为有I/O的容器使用时，缓冲区头会促使内核把大块数据的I/O操作分解为多个buffer_head结构体进行操作，这样做必然会造成不必要的负担和空间浪费。
6.bio结构体（目前内核中块I/O操作基本的容器）：代表了正在现场的（活动的）以片段链表形式组织的块I/O操作。一个片段时一小块连续的内存缓冲区。这样的话，就不需要保证单个
缓冲区一定要连续。所以通过用片段来描述缓冲区，即使一个缓冲区分散在内存的多个位置上，bio结构体也能对内核保证I/O操作执行。
7.新老方法对比
	缓冲区头和新的bio结构体之前存在显著差别。bio结构体代表的时I/O操作，它可以包括内存中的一个或多个页；而另一个方面，buffer_head结构体代表的是一个
缓冲区，它描述的仅仅是磁盘中的一个块。
	利用bio结构体代替buffer_head好处：
	1）bio结构体很容易处理高端内存，因为它处理的是物理页而不是直接指针
	2）bio结构体既可以代表普通页i/O,同时也可以代表直接I/O
	3）bio结构体便于执行分散-集中（矢量化的）块I/O操作，操作中的数据可取自多个物理页面。
	4）bio结构体相比缓冲区头属于轻量级的结构体。因为它只需要包含块I/O操作所需要的信息就行了，不用包含于缓冲区本身相关的不必要信息。
8.但是还是需要缓冲区头这个概念，毕竟它还负责描述磁盘块到页面的映射。bio块结构体不包含任何和缓冲区相关的状态信息--它仅仅是一个矢量数组，描述
一个或多个单独块I/O操作的数据片段和相关信息。当前设置中，当bio结构体描述当前正在使用的I/O操作时，buffer_head结构体仍然需要包含缓冲区信息。
9.请求队列：快设备将它们挂起的块I/O请求保持在请求队列中，该队列由reques_queue结构体表示，包含一个双向请求链表以及相关控制信息。
10.I/O调度程序：负责提交I/O请求的子系统
	1）I/O调度程序的工作是管理块设备的请求队列。决定队列中的请求排列顺序以及在什么时刻派发请求到块设备。这样做有利于减少磁盘寻址时间，从而提高
全局吞吐量。
	2）I/O调度程序通过两种方法减少磁盘寻址时间：合并于排序。
11.Linus电梯，当一个请求加入到队列时，有可能发生四种操作：
	1）如果队列中已存在一个对相邻扇区操作的请求，那么新请求将和这个已经存在的请求合并成一个请求。
	2）如果队列中存在一个驻留时间过长的请求，那么新请求将被插入到队列尾部，以防止其他旧的请求饥饿发生。
	3）如果队列中以扇区方向为库存在合适的插入位置，那么新的请求将被插入到该位置，保证队列中的请求是以被访问磁盘物理位置为序进行排列的。
	4）如果队列中不存在合适的请求插入位置，请求将被插入到队列尾部。
12.最终期限I/O调度程序：为了解决Linus电梯所带来的饥饿问题而提出的。
	1）在最后期限I/O调度程序中，每个请求都有一个超时时间。默认情况下，读请求的超时时间是500ms,写请求的超时时间是5s。
	2）请求类似于linus电梯中，维护一个排列队列，超时的分布放入一个读FIFO队列，写FIFO队列
13.预测I/O调度程序:克服最终期限I/O调度程序的降低系统吞吐量问题
	1）基本和最终期限I/O调度程序一样，在之上增加了一个预测启发能力。
	2）预测I/O调度试图减少在进行I/O操作期间，处理新到的读请求所带来的寻找数量。
14.完成公正的排队I/O调度程序（默认）
	1）以时间片轮转调度队列，从每个队列中选取请求数（默认值为4），然后进行下一轮调度。
15.空操作的I/O调度程序：不进行排序，也不进行预寻址操作。但是会合并。--->闪存卡
16.启动时，通过命令选择elevator=as/cfd/deadline/noop(预测/完全公正的排队/最终期限/空操作)





























































