1.中断（广义）：会改变处理器执行指令的顺序，通常与CPU芯片内部或外部硬件电路产生的电信号相对应
1）中断——异步的：由硬件随机产生，在程序执行的任何时候可能出现
2）异常——同步的：在（特殊的或出错的）指令执行时由CPU控制单元产生
我们用“中断信号”来通称这两种类型的中断
2.中断信号的作用
1）中断信号提供了一种特殊的方式，使得CPU转去运行正常程序之外的代码
2）当一个中断信号到达时，CPU必须停止它当前正在做的事，并且切换到一个新的活动 
3）在进程的内核态堆栈保存程序计数器的当前值(即eip和cs寄存器)以便处理完中断的时候能正确返回到中断点
4）并把与中断信号相关的一个地址放入进程序计数器，从而进入中断的处理
3.中断信号的处理原则
1）内核的目标就是让中断尽可能快的处理完，尽其所能把更多的处理向后推迟
2）允许不同类型中断的嵌套发生，这样能使更多的I/O设备处于忙状态
3）尽管内核在处理一个中断时可以接受一个新的中断，但在内核代码中还在存在一些临界区，在临界区中，中断必须被禁止
4.中断上下文
1）中断上下文不同于进程上下文 
2）中断或异常处理程序执行的代码不是一个进程。它是一个内核控制路径，代表了中断发生时正在运行的进程执行
3）作为一个进程的内核控制路径，中断处理程序比一个进程要“轻”(中断上下文只包含了很有限的几个寄存器，建立和终止这个上下文所需要的时间很少
5.中断分为：
1）可屏蔽中断（Maskable interrupt） 
	i.I/O设备发出的所有中断请求(IRQ)都可以产生可屏蔽中断。
    ii.可屏蔽中断可以处于两种状态:屏蔽的(masked)和非屏蔽的(unmasked)
2）非屏蔽中断（Nonmaskable interrupt） 
    只有几个特定的危急事件才引起非屏蔽中断。如硬件故障或是掉电
5.异常分为：
1）处理器探测异常 
由CPU执行指令时探测到一个反常条件时产生，如溢出、除0错等
2）编程异常 
由编程者发出的特定请求产生，通常由int类指令触发
通常叫做“软中断”：例如系统调用	
6.中断向量
1）每个中断和异常由0~255之间的一个数（8位）来标识，Intel称其为中断向量。
2）非屏蔽中断的向量和异常的向量是固定的
3）可屏蔽中断的向量可以通过对中断控制器的编程来改变
7.中断的产生
1）每个能够发出中断请求的硬件设备控制器都有一条称为IRQ(Interrupt ReQuest)的输出线。
2）所有的IRQ线都与一个中断控制器的输入引脚相连
3）中断控制器与CPU的INTR引脚相连
8.中断描述符表(Interrupt Descriptor Table，IDT)
1）中断描述符表是一个系统表，它与每一个中断或者异常向量相联系 
2）每个向量在表中有相应的中断或者异常处理程序的入口地址。
3）每个描述符8个字节，共256项，占用空间2KB。
4）内核在允许中断发生前，必须适当的初始化IDT
5）CPU的idtr寄存器指向IDT表的物理基地址 
6）在允许中断之前，必须用lidt汇编指令初始化idtr。
9.抢占原则
1）普通进程可以被中断或异常处理程序打断
2）异常处理程序可以被中断程序打断
3）中断程序只可能被其他的中断程序打断
10.异常的处理：
1）CPU产生的大部分异常都由linux解释为出错条件。
   当一个异常发生时，内核就向引起异常的进程发送一个信号通知它发生了一个反常条件
2）异常处理有一个标准的结构，由三部分组成
   i.在内核态堆栈中保存大多数寄存器的内容
   ii.调用C语言的函数
   iii.通过ret_from_exception()从异常处理程序退出
3）entry_32.S中error_code()该函数的主要功能： 
   i.按照pt_regs结构定义的堆栈数据格式完成相应的入栈操作，进一步完成现场的保存
   ii.把堆栈地址中的do_handler_name()函数的地址装入edi寄存器中，并在这个位置写入fs值，使栈结构进一步与pt_regs结构完全一致。
   iii.最后执行call *%edi指令
11.中断处理：
1）中断跟异常不同，它并不是表示程序出错，而是硬件设备有所动作，所以不是简单地往当前进程发送一个信号就OK的
2）主要有三种类型的中断 
i.I/O设备发出中断请求
ii.时钟中断
iii.处理器间中断
3）处理程序都执行四个相同的基本操作 
i.在内核态堆栈保存IRQ的值和寄存器的内容
ii.为正在给IRQ线服务的PIC发送一个应答，这将允许PIC进一步发出中断
iii.执行共享这个IRQ的所有设备的中断服务例程
iv.跳到ret_from_intr()的地址后中断跳出
12.软中断、tasklet以及下半部分
1）对内核来讲，可延迟中断不是很紧急，可以将它们从中断处理例程中抽取出来，保证较短的中断响应时间
2）Linux2.6提供了三种方法 
i.可延迟的函数
  软中断、tasklet
  Tasklet在软中断之上实现
  一般原则：在同一个CPU上软中断/tasklet不嵌套
  软中断由内核静态分配（编译时确定）
  Tasklet可以在运行时分配和初始化（例如装入一个内核模块时）
ii.工作队列（ work queues ）
3）工作队列和tasklet这两种下半部机制的主要区别在于： 
i.Tasklet在软中断的上下文中运行，所有的代码必须是原子的，不能睡眠、不能使用信号量或其它产生阻塞的函数；
ii.工作队列在一个内核线程上下文运行，并且可以在延迟一段确定的时间后才执行；有更多的灵活性，它可以使用信号量等能够睡眠的函数。
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	