一、linux进程的标准内存段布局：
（4G-3G）内核空间----->（3G-0）用户空间（栈-->内存映射区-->堆-->BSS段-->data段-->程序段）
1）程序段(Text):程序代码在内存中的映射，存放函数体的二进制代码。
2）初始化过的数据(Data):在程序运行初已经对变量进行初始化的数据。
3）未初始化过的数据(BSS):在程序运行初未对变量进行初始化的数据。
4）栈 (Stack):存储局部、临时变量，函数调用时，存储函数的返回指针，用于控制函数的调用和返回。在程序块开始时自动分配内存,结束时自动释放内存，其操作方式类似于数据
结构中的栈。
5）堆 (Heap):存储动态内存分配,需要程序员手工分配,手工释放.注意它与数据结构中的堆是两回事，分配方式类似于链表。
二、Linux进程状态解析 之 R、S、D、T、Z、X （主要有三个状态）
1.Linux进程状态：R (TASK_RUNNING)，可执行状态。
    只有在该状态的进程才可能在CPU上运行。而同一时刻可能有多个进程处于可执行状态，这些进程的task_struct结构（进程控制块）被放入对应CPU的可执行队列中（一个进程最多只能出现在
一个CPU的可执行队列中）。进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行。
2.Linux进程状态：S (TASK_INTERRUPTIBLE)，可中断的睡眠状态。
    处于这个状态的进程因为等待某某事件的发生（比如等待socket连接、等待信号量），而被挂起。这些进程的task_struct结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断
触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。
3.Linux进程状态：D (TASK_UNINTERRUPTIBLE)，不可中断的睡眠状态。
    与TASK_INTERRUPTIBLE状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。绝大多数情况下，进程处
在睡眠状态时，总是应该能够响应异步信号的。否则你将惊奇的发现，kill -9竟然杀不死一个正在睡眠的进程了！于是我们也很好理解，为什么ps命令看到的进程几乎不会出现
TASK_UNINTERRUPTIBLE状态，而总是TASK_INTERRUPTIBLE状态。
4.Linux进程状态：T (TASK_STOPPED or TASK_TRACED)，暂停状态或跟踪状态。
    向进程发送一个SIGSTOP信号，它就会因响应该信号而进入TASK_STOPPED状态（除非该进程本身处于TASK_UNINTERRUPTIBLE状态而不响应信号）。（SIGSTOP与SIGKILL信号一样，是非常强制的。
不允许用户进程通过signal系列的系统调用重新设置对应的信号处理函数。）向进程发送一个SIGCONT信号，可以让其从TASK_STOPPED状态恢复到TASK_RUNNING状态。
5.Linux进程状态：Z (TASK_DEAD - EXIT_ZOMBIE)，退出状态，进程成为僵尸进程。
    进程在退出的过程中，处于TASK_DEAD状态。在这个退出过程中，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故
称为僵尸。
6.Linux进程状态：X (TASK_DEAD - EXIT_DEAD)，退出状态，进程即将被销毁。
     而进程在退出过程中也可能不会保留它的task_struct。比如这个进程是多线程程序中被detach过的进程（进程？线程？参见《linux线程浅析》）。或者父进程通过设置SIGCHLD信号的handler
为SIG_IGN，显式的忽略了SIGCHLD信号。（这是posix的规定，尽管子进程的退出信号可以被设置为SIGCHLD以外的其他信号。）