X86-32位：
逻辑地址-->分段单元-->线性地址-->分页单元-->物理地址
1. 虚拟地址、物理地址、逻辑地址、线性地址
   虚拟地址又叫线性地址。linux没有采用分段机制，所以逻辑地址和虚拟地址（线性地址）（在用户态，内核态逻辑地址专指下文说的线性偏移前的地址）是一个概念。
   物理地址自不必提。内核的虚拟地址和物理地址，大部分只差一个线性偏移量。用户空间的虚拟地址和物理地址则采用了多级页表进行映射，但仍称之为线性地址。
2.在x86结构中，Linux内核虚拟地址空间划分0~3G为用户空间，3~4G为内核空间(注意，内核可以使用的线性地址只有1G)。内核虚拟空间（3G~4G）又划分为三种类型的区：
ZONE_DMA 3G之后起始的16MB
ZONE_NORMAL 16MB~896MB
ZONE_HIGHMEM 896MB ~1G：高端内存（解决只能访问1G物理内存问题）
有一部份用来做非连续空间的物理映射（vmalloc）.除掉这部份空间之外，只留下896M大小供内核映射到物理地址。
3.kmalloc、vmalloc和malloc的区别
1）kmalloc和vmalloc是分配的是内核的内存,malloc分配的是用户的内存
2）kmalloc保证分配的内存在物理上是连续的,内存只有在要被DMA访问的时候才需要物理上连续，malloc和vmalloc保证的是在虚拟地址空间上的连续
3）kmalloc能分配的大小有限,vmalloc和malloc能分配的大小相对较大
4）vmalloc比kmalloc要慢。 尽管在某些情况下才需要物理上连续的内存块，但是很多内核代码都用kmalloc来获得内存，而不是vmalloc。这主要是出于性能的考虑。
vmalloc函数为了把物理内存上不连续的页转换为虚拟地址空间上连续的页，必须专门建立页表项。糟糕的是，通过vmalloc获得的页必须一个个地进行映射，因为它
们物理上是不连续的，这就会导致比直接内存映射大得多的TLB抖动，vmalloc仅在不得已时才会用--典型的就是为了获得大块内存时。
5.malloc函数实现原理
   malloc函数的实质体现在，它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表(全局变量，一个内存块的链表指针)。调用malloc函数时，它沿连接表寻找
一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用
户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。调用free函数时，它将用户释放的内存块连接到空闲链上。到最后，空闲链会被切成很多的
小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检
查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。 
6.伙伴算法
1）伙伴Buddy算法解决了外部碎片问题.内核在每个zone区管理着可用的页面，按2的幂级（order）大小排成链表队列，存放在free_area数组。
	外部碎片：
	i.在内存上，位于任何两个操作系统分配的用于装载进程的内存区域或页面之间的空闲区域称为外部碎片
    ii.在磁盘上，将文件分割成几块不相连的分片，这样不相连的分片叫做文件碎片，也即外部碎片。如果将文件分割成几块相连的分片，这样相连的分片则不是文件碎片。
2）Buddy（伙伴的定义）：
   i.两个块大小相同；
   ii.两个块地址连续；
   iii.两个块必须是同一个大块中分离出来的；
3）把所有的空闲页框分组为 11 块链表，每一块链表分别包含大小为1，2，4，8，16，32，64，128，256，512 和 1024 个连续的页框。对1024 个页框的最大请求对应着 4MB 
大小的连续RAM 块。每一块的第一个页框的物理地址是该块大小的整数倍。例如，大小为 16个页框的块，其起始地址是 16 * 2^12 （2^12 = 4096，这是一个常规页的大小）的
倍数。
4）分配原理：假如系统需要4(2*2)个页面大小的内存块，该算法就到free_area[2]中查找，如果链表中有空闲块，就直接从中摘下并分配出去。如果没有，算法将顺着数组向上
查找free_area[3],如果free_area[3]中有空闲块，则将其从链表中摘下，分成等大小的两部分，前四个页面作为一个块插入free_area[2]，后4个页面分配出去，free_area[3]中
也没有，就再向上查找，如果free_area[4]中有，就将这16(2*2*2*2)个页面等分成两份，前一半挂如free_area[3]的链表头部，后一半的8个页等分成两等分，前一半
挂free_area[2]的链表中，后一半分配出去。假如free_area[4]也没有，则重复上面的过程，知道到达free_area数组的最后，如果还没有则放弃分配。
5）回收原理：释放一个块时，先在其对应的链表中考查是否有伙伴存在，如果没有伙伴块，就直接把要释放的块挂入链表头；如果有，则从链表中摘下伙伴，合并成一个大块，
然后继续考察合并后的块在更大一级链表中是否有伙伴存在，直到不能合并或者已经合并到了最大的块(2*2*2*2*2*2*2*2*2个页面)。
7.slab分配器：解决内部碎片问题（内部碎片的产生主要是由于请求内存的大小与分配给它的大小不匹配而造成的）
1）内核如何处理对一些数据结构分配内存空间，大多数数据结构根本占用不到一个页框。我们如何处理对小内存区的请求呢，比如说几十或几百个字节？（页大小为4KB）。
2）内核通常依赖于对小对象的分配，它们会在系统生命周期内进行无数次分配。slab 缓存分配器通过对类似大小（远小于1page）的对象进行缓存而提供这种功能，从而避免了
常见的内部碎片问题。
3）用一段话来描述slab。就是讲内存按照对象为单位进行组织，一定数目的对象聚集在一起称为一个slab。系统通过操作slab来进行内存的分配。每个CPU上的per-CPU结构中，
保存了空闲的对象指针，通过这些指针，系统可以快速有效的进行对象分配。
8.malloc分析-从用户空间到内核空间
malloc是glibc中内存分配函数，也是最常用的动态内存分配函数，其内存必须通过free进行释放，否则导致内存泄露。关于 malloc 获得虚存空间的实现，与glibc的版本有关，但大体逻辑是：
1）申请128k以内的内存，调用sbrk()，在堆内分配，将堆顶指针向高地址移动，获得新的虚存空间。虚拟地址比较小。（类似于一个链表中）
2）每次分配的内存地址前16字节（64位系统，32位是8字节）是记录该内存块的控制信息（用于 free ）。
3）并不是每次malloc都会导致堆顶的增大，如果堆内有足够剩余空间，堆顶不会发生变化。
4）当分配大小大于128k，使用mmap在文件映射区域中分配匿名虚存空间获得地址空间，地址一般比较大（靠近栈区间）
5）可通过函数mallopt(M_MMAP_THRESHOLD, 64*1024) 修改使用 mmap 的临界值为 64k ，后续大于 64k 的分配就会使用 mmap.

Linx内存管理--段式和页式管理
CPU要将一个逻辑地址转换为物理地址，需要两步：首先CPU利用段式内存管理单元，将逻辑地址转换程线性地址，再利用页式管理单元，把线性地址最终转换为物理地址。
逻辑地址=段基地址：偏移地址
其中：段基地址保存到段寄存器中，偏移地址保存另个寄存器中
线性地址= 段基地址*16+偏移地址（32位*32，16位*16）

页式地址转换：
第一步：装入进程的页目录地址（操作系统在调度进程时，把这个地址装入CR3）
第二步：根据线性地址前十位，在页目录中，找到对应的索引项 即页表地址。
第三步：根据线性地址中间十位，在页表中，找到对应的索引项 即页的起始地址。
第四步：将页的起始地址与线性地址最后12位相加，等到物理地址。






























