   虚继承是解决c++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间
第二，存在二义性问题，通常可以将派生类对象的地址赋给基类对象，实现的具体方式是，将基类将基类指针指向继承类（继承类有基类的拷贝）
中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。
虚继承可以解决多种继承前面提到的两个问题：

    虚继承底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）
和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；
当虚继承的子类被当做父类继承时，虚基类指针也会被继承。



   实际上，vbptr指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与
本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，
节省了存储空间。



    在这里我们可以对比虚函数的实现原理：他们有相似之处，都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）。

    虚基类依旧存在继承类中，只占用存储空间；虚函数不占用存储空间。

    虚基类表存储的是虚基类相对直接继承类的偏移；而虚函数表存储的是虚函数地址。

从上面的两张图中可以发现，虚继承时的派生类对象被分成了两部分：
不带阴影的一部分偏移量固定，不会随着继承层次的增加而改变，称为固定部分；
带有阴影的一部分是虚基类的子对象，偏移量会随着继承层次的增加而改变，称为共享部分。
7
当要访问对象的成员变量时，需要知道对象的首地址和变量的偏移，对象的首地址很好获得，关键是变量的偏移。对于固定部分，偏移是不变的，
很好计算；而对于共享部分，偏移会随着继承层次的增加而改变，这就需要设计一种方案，在偏移不断变化的过程中准确地计算偏移。
对于虚继承，将派生类分为固定部分和共享部分，并把共享部分放在最后，几乎所有的编译器都在这一点上达成了共识。主要的分歧就是如何计算
共享部分的偏移，可谓是百花齐放，没有统一标准。
各个编译器正是在设计这一方案时出现了分歧，不同的编译器设计了不同的方案来计算共享部分的偏移。

http://blog.chinaunix.net/uid-16723279-id-3568748.html

在虚继承的情况下内存空间分布：
1、B1的虚函数表（子类重定义的基类的虚函数、重定义的B1的虚函数、子类自己的虚函数）
2、继承自B1的数据成员
3、B2的虚函数表（子类重定义的基类的数据成员、重定义的B2的虚函数）
4、继承自B2的数据成员
5、子类自己的数据成员
6、基类的虚函数表（子类重定义的虚函数、基类的虚函数）
7、基类的数据成员

对于微软，提供的是由一根指针指针指向基类，用以解决对象不变，额外开销一定；此法未公开使用

第二种方法利用offset;在派生类的虚函数表中（第一行）存一个基类的偏移量，在新的sum编译中，利用正负值索引来加以区分，正值索引到虚函数
，负值索引到虚基类的偏移量（需要提供一个算法来计算）































