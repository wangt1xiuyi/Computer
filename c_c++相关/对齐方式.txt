内存对齐：
    许多实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k(通常会是4或8)的倍数；每个特定平台上的编译器都有自己的默认“对齐系统数”（32位一般为4，64位为8），我们可以通过预编译命令#pragma pack(k)，k=1,2,4,8,16来改变这个系数；也可以使用#pragma pack（）取消自定义字节对齐方式。

struct或者union成员对齐规则如下：
    1.第一个数据成员放在offset为0的地方，对齐按照对齐系数和自身占用字节数中，二者比较小的进行对齐；
    2.在数据成员完成各自对齐后，struct或者union本身也要进行对齐，对齐将按照对齐系数和struct或者union中最大数据成员长度中比较小的那个进行；
总的就是：先局部对齐，在全局对齐；

对齐三准则：
1.结构体变量的首地址能够被其最宽基本类型成员的大小所整除；
2.结构体每个成员相对于结构体首地址偏移量都是成员大小的整数倍，如有需要编译器会在成员之间填充字节
3.结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后填上填充字节；

linux下double的对齐方式为4字节，而Windows默认是八字节；


准则1：前面的地址必须是后面的整数倍，不然就对齐

准则2：整个struct的地址必须是最大字节的整数倍