第一章 温故而知新
1.直接将物理内存分配给多个程序使用的坏处：地址空间不隔离、内存使用效率低、程序运行的地址不确定
--->虚拟地址
2.线程，有时称为轻量级进程，是程序执行流的最小单元。
线程私有：局部变量、函数参数、TLS数据
线程之间共享：全局变量、堆上的数据、函数里的静态变量、程序代码、打开的文件
3.当线程数量小于等于处理器数量时（并且操作系统支持多处理器），线程的并发是真正的并发，不同的线程运行在不同的处理器上，彼此之间互不相干。
4.线程调度至少拥有三种状态：
     1）运行：此时线程正在执行
	 2）就绪：此时线程可以立刻运行，但CPU已被占用
	 3）等待：此时线程正在等待某一事件发生，无法执行。
5.线程的优先级改变一般有三种方式：
	1）用户指定优先级
	2）根据进入等待状态的频繁程序提升或降低优先级
	3）长时间得不到执行而被提升优先级
6.可重入与线程安全
1）一个函数被重入，表示这个函数没有执行完成，由于外部因素或内部调用，又一次进入该函数执行。只有两种情况：（1）多个线程同时执行这个函数；（2）函数自身调用自身
一个函数称为可重入的，表明函数被重入之后不会产生任何不良后果。
2）一个函数要成为可重入的，必须具有如下几个特点：
	i.不使用任何（局部）静态或全局的非const变量；
	ii.不返回任何（局部）静态或全局的非const变量的指针；
	iii.仅依赖调用方提供的参数
	iv.不依赖任何单个资源的锁（mutex等）
	v.不调用任何不可重入的函数。
3）防止编译器的过度优化：volatile
	1）阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回；
	2）阻止编程器调整操作volatile变量的指令顺序。
4）但是volatile不能阻止CPU的过度优化--动态调度换序；这个时候需要优化屏障（读屏障、写屏障、通用屏障等）--barrier()函数。
7.三种线程模型--用户态线程与内核线程的对于关系
1）一对一模型：一个用户使用的 线程就唯一对应一个内核使用的线程，反之不一定（clone）
2）多对一模型：多个用户线程映射到一个内核线程上。
3）多对多模型：结合了多对一模型和一对一模型的特点。

二、静态链接
一般程序的编译过程：预处理-->编译-->汇编-->链接
1.预编译过程：
1）将所有的“#define”删除，并且展开所有的宏定义。
2）处理所有条件预编译指令，比如“#if”,"ifdef","elif","else"、"#endif"等。
3）处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。注意这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件。
4）删除所有的注释“//”和“/* */”;
5）添加行号和文件标识号，比如#2 “hello.c” ,以便编译器产生调试用的行号
6）保留所有的#pragma编译器指令，因为编译器必须使用它们。
产生为 .i文件 
g++ -E .....
2.编译
        词法分析(lex)                    语法分析(yacc)     语义分析                  源代码优化          代码生成          目标代码优化
源代码------------>产生一堆单词（token）------------>语法树---------->带变量的语法树----------->中间语言---------->目标代码------------->最终目标代码
g++ -S ....
c语言中，最小的单位是变量和函数
3.链接包括：地址和空间分配、符号决议和重定位等

三、目标文件
Linux下ELF文件类型：可重定位文件、可执行文件、共享目标文件、核心转储文件
1.总体来说，程序源代码被编译以后主要分成两种段：程序指令和程序数据。代码段（.text）属于程序指令，而数据段（.data）和.bss段属于程序数据
2.将数据和代码分开放的原因：
	1）防止程序的指令被有意或无意地修改；
	2）可以提高缓存的命中率；
	3）可以实现共享，代码段共享等，介绍大量空间。
查看目标文件命令：objdump -h hello.o：查看头部信息     size hello.o:查看ELF文件的代码段、数据段和BSS段的长度
				  objdump -s -d hello.o:所有内容以十六进制打印出来，并且进行反汇编
3. .rodata段存放的是只读数据，一般是程序里面的只读变量（如const修饰的变量）和字符串常量
4.readelf -h hello.o：查看ELF文件
  readelf -S hello.o
5.链接的接口--符号
符号表（.symtab）：记录函数/变量名及其地址；（查看，nm hello.o）
未解决符号表提供了所有在该编译单元里引用但是定义并不是在本编译单元的符号及其出现的地址（extern声明）
导出符号表提供了本编译单元具有定义，并且愿意提供给其他单元使用的符号及其地址；
地址重定向表提供了本编译单元所有对自身地址的引用的记录
注意：static声明的全局变量不置入任何符号表，属于内部链接。普通函数置入导出符号表
6.不同的函数名，在c++中加了函数签名以区分；c函数中在window平台下会加下划线以区分，而linux默认什么都不加
7.针对“_cplusplus”,c++编译器会在编译c++程序时默认定义这个宏，可以利用来判断当前编译单元是不是C++代码
8.多个目标文件中含有相同名字全局符号的定义，那么这些目标文件链接的时候会出现符号重定义的错误。这种符号定义被称为强符号
9.编译器默认函数和初始化了的全局变量为强符合，未初始化的全局变量为弱符号。可以通过“__attribute__((weak))”来定义任何一个强符合为弱符号。
需要注意的是，强符合和弱符号都是针对定义来说，不是针对符号的引用。
10.针对强弱符号的概念，链接器会按如下规则处理与选择被多次定义的全局符合：
1）不允许强符合被多次定义，如果有多个强符合定义，则链接器报符号重复定义错误
2）如果一个符号在目标文件是强符号，在其他文件中都是弱符号，那么选择强符号
3）如果一个符号在所有目标中都是弱符号，那么选择其中占用空间最大的一个。
11.强引用：对外部目标文件的符号引用在目标文件被最终链接成可执行文件时，需要被正确决议，如果没有找到该符号的定义，链接器会报符号未定义错误。
   弱引用：基于强引用情况下，不会报错。利用“__attribute__((weakref))”扩展。

四、静态链接详解
1.多个目标文件链接合并方法：相似段合并，比如所有输入文件的“.text”合并到输出文件的“.text”段，接着是“.data段”、“.bss”段等。
2.现在的链接器空间分配的策略基本上采用两步链接法：
	第一步 空间与地址分配
	第二部 符号解析与重定位
链接器：ld a.o b.o -e main -o ab  -->-e main表示将main函数作为程序入口，ld链接器默认的程序入口为_start。 -o和gcc类似的
3.对于目标文件来说，链接之前，目标文件代码段中的起始地址以Ox00000000开始，等到空间分配完成以后，各个函数才会确定自己在虚拟地址空间中的位置。
4.重定位表的结构专门用来保存这些与重定位相关的信息。
5.c++编译器很多时候会产生重复的代码，比如模板、外部内联函数和虚函数表都有可能在不同的编译单元里生成相同的代码。会造成以下问题：
	1）空间浪费
	2）地址较易出错。有可能两个指向同一个函数的指针会不相等。
	3）指令运行效率低。因为现代的CP都会对指令和数据进行缓存，如果同样一份指令有多份副本，那么指令Cache的命中率就会降低。
6.c++的全局对象的构造函数在main之前被执行，C++全局对象的析构函数在main之后被执行。
7.Linux系统下一般程序的入口是“_start”。
8.c++最大的一个毛病-->二进制兼容性不好
9.一般链接器有三种方法：第一是使用命令行来给链接器指定参数（ld），第二是将链接指令放在目标文件里面，编译器经常会通过这种方法向链接器传递指令（常用）。
第三种是使用链接控制脚本。、

第五章 Windows PE/COFF
1.跟ELF一样，PE种也允许程序员将变量或函数放到自定义的段。在GCC种我们使用“__attribute__(section("name"))”扩展属性，在visual C++种可以使用“#pragmatic”编译器指示
例如：
	#pragma data_seg("FOO")
	int global=1;
	#pragma data_seg(".data")
	可以将全局变量global放到FOO段里面去，然后再使用”#pragram“将这个编译器指示换回来。

第六章 可执行文件的装载与进程
1.Linux下3GB空间分配给用户空间（进程执行时，所有代码、数据包括申请的虚拟空间之和不超过3GB），1G分配给内核；
  Windows下默认是2G给用户空间，2G给内核，当然可以修改，在Windows系统盘根目录下的Boot.ini，加上"/3G"参数。
2.32位的CPU下，程序使用的空间能不能超过4GB呢，如果是虚拟空间，不能，如果是物理空间，可以，因为映射，采用了36位物理地址，高达64GB
3.覆盖装入（淘汰）和页映射两种典型的动态装载方法-->解决程序所需要的内存数量大于物理内存的数量：最常用的部分驻留在内存中。
4.页映射：两种置换策略FIFO(先进先出)和LRU(最少使用)
5.进程的建立：1.创新虚拟地址空间，2.读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。3.将CPU的指令寄存器设置成可执行文件的入口地址，启动运行
6.为了减少内存碎片，对于相同权限的段，把它们合并到一起当作一个段进行映射。
7.一个进程基本上可以分为如下几种VMA区域：
1）代码VMA，权限只读、可执行;有映像文件
2）数据VMA，权限可读写、可执行；有映像文件
3）堆VMA,权限可读写、可执行；无映像文件，匿名，可向上扩展
4）栈VMA，权限可读写，不可执行；无映像文件，匿名，可向下扩展
8.Linux内核装载ELF过程
1）bash进程会调用fork()系统调用创建一个新的进程，然后新的进程调用execve()系统调用执行指定得ELF文件，原先得bash进程继续返回等待刚才启动得新进程结束
然后等待用户输入命令。
2）execve()系统调用执行过程：
	i.检查ELF可执行文件格式的有效性，比如魔数、程序表头中段的数量。（特别是开头4字节，一般128字节）
	ii.寻找动态链接的”.interp“段，设置动态链接器路径
	iii.根据ELF文件可执行文件的程序头表的描述，对ELF文件进行映射，比如代码、数据、只读数据。
	iv.初始化ELF进程环境，比如进程启动时EDX寄存器的地址应该是DT_FINI的地址
	v.将系统调用返回地址修改成ELF可执行文件的入口点，这个入口点取决于程序的链接方式，对于静态链接的ELF可执行文件，这个程序入口就是ELF文件的文件头中e_entry所指
	的地址；对于动态链接的ELF可执行文件，程序入口点是动态链接器。

第七章 动态链接
1.静态链接库的空间浪费、程序的更新、部署和发布也会带来很多麻烦；动态链接解决了空间浪费和更新困难的问题。
2.动态链接基本思想：将链接这个过程推迟到了运行时再进行。减少物理页面的换入换出，增加了CPU缓存的命中率。
3.利用动态链接在程序运行时可以动态地加载各种程序模块这个优点，后来被人们用来制作程序的插件。
4.动态链接常见的一个问题，当程序所依赖的某个模块更新后，由于新的模块与旧的模块之间接口不兼容，导致了原有的程序无法运行。
5.Linux下，ELF动态链接文件被称为动态共享对象，简称共享对象，以”.so“为扩展名的一些文件；而在windows系统中，动态链接文件被称为动态链接库，以“.dll”为扩展名
6.“-shared”参数，表示装载时重定位，以解决动态模块中有绝对地址引用的办法之一。
7.“-fPIC”,产生地址无关代码
8.延迟绑定--优化动态链接性能
    基本思想就是当函数第一次被用到时才进行绑定（符号查找，重定位等），如果没有用到则不进行绑定。
ELF使用PLT的方法来实现，使用了一些很精巧的指令序列来完成。
9.“.interp”段-->可执行文件所需要的动态链接器的路径，“.dynamic”-->这个段里面保存了动态链接器所需要的基本信息，“.dynsym”-->动态符号表
10.动态链接的步骤和实现
	1）启动动态链接器本身
	2）装载所有需要的共享对象
	3）重定位和初始化
11.动态链接器自举-->放在无休止的循环
	1）编写动态链接器时保证不使用任何系统库、运行库
	2）动态链接器启动时有一段非常精巧额的代码可以完成这项艰巨的工作同时又不能用到全局变量和静态变量
12.动态链接器本身应该是静态链接的，装载地址是一个一开始是无效的地址（0X0000000000）,装载过程中会选择一个合适的装载地址。

第十章 内存
1.堆栈帧一般包括：
	1）函数的返回地址和参数
	2）临时变量b：包括函数的非静态局部变量以及编译器自动生成的其他临时变量
	3）保存的上下文，包括在函数调用前后需要保持不变的寄存器
2._cdecl(linux下为__attribute__((cdcel)))默认的c惯例：从右至左的顺序压参数入栈，函数调用方出栈，直接在函数名前加1个下划线进行名字修饰。
3.其他调用惯例
调用惯例          出栈方            参数传递                            名字修饰
stdcall           函数本身         从右至左顺序参数入栈               下划线+函数名+@+参数的字节数
fastcall          函数本身        头两个DWORD(4字节)类型或者           @+函数名+@+参数的字节数
                                  占更少字节的参数被放入寄存器
								  ，其他剩下的参数按照从右到左
pascal            函数本身         从左到右的顺序压参数入栈            较为复杂
4.函数返回值一般在8字节以内，放在寄存器内，如果太大，则：
	1）首先main函数在栈上额外开辟了一片空间，并将这块空间的一部分作为传递返回值的临时对象，这里称为temp
	2）将temp对象的地址作为隐藏参数传递给return_test函数
	3）将return_test函数将数据拷贝给temp对象，并将temp对象的地址用eax传出
	4）return_test返回之后，main函数将eax指向的temp对象的内容拷贝给n
5.管理着堆空间分配的往往是程序的运行库-->程序向操作系统申请一块适当大小的堆空间，然后由程序自己管理这块空间
6.两种堆空间分配的方式，两个系统调用:一个是brk()系统调用，另外一个是mmap()
7.glibc的mallo函数是这样处理用户空间请求的：对于小于128KB的请求来说，它会在现有的堆空间里面，按照堆分配算法为它分配一块空间并返回；对于
128KB的来说，它会使用mmap()函数为它分配一块匿名空间，然后在这个匿名空间中为用户分配空间。
8.匿名空间：mmap本来申请一段虚拟地址空间，可以映射到某个文件，当它不将地址空间映射到某个文件时，称这块空间为匿名空间
9.malloc大约能申请到2G多空间
10.堆分配算法
	1）空闲链表：把堆中各个空闲的块按照链表的方式连接起来
	2）位图
	3）对象池
第十一章 运行库
1.操作系统装载程序之后，首先运行的代码并不是main的第一行，而是某些特别的代码，这些代码负责准备好main函数执行所需要的环境，并且负责调用main函数。
2.一个典型的程序运行步骤大致如下：
	1）操作系统在创建进程后，把控制权交到了程序的入口，这个入口往往是运行库中的某个入口函数。
	2）入口函数对运行库和程序运行环境进行初始化，包括堆、I/O、线程、全局变量构造，等等。
	3）入口函数在完成初始化之后，调用main函数，正式开始执行程序主体部分。
	4）main函数执行完毕以后，返回到入口函数，入口函数进行清理工作，包括全局变量析构、堆销毁、关闭I/O等，然后系统调用结束进程。
3.glibc入口函数：入口为_start（LINUX下）；MSVC CRT 入口函数（WINDOWS）
4.Linux里，文件叫做文件描述符，在windows中叫做句柄。
5.MSVC的I/O初始化主要进行以下工作：
	1）建立打开文件表；
	2）如果能够继承父进程，那么从父进程获取继承的句柄；
	3）初始化标准输入输出。
6.c语言运行库大致包含如下功能：
	1）启动与退出：包括入口函数以及入口函数所依赖的其他函数等。
	2）标准函数：由c语言标准规定的C语言标准库所拥有的函数实现。
	3）I/O：I/O功能的封装和实现
	4）堆：堆的封装和实现
	5）语言实现
	6）调试：实现调试功能的代码
7.变长参数（stdarg.h）
通过宏定义来读取参数：
	va_list ap;
	va_start(ap,lastarg);//lastarg是函数的最后一个具名的参数
	type next=va_arg(ap,type):获取下一个不定参数
	va_end(ap):清理现场。
8.int fflush(FILE *stream):flush指定文件的缓冲，若参数NULL,则flush所有文件的缓冲，
  int setvbuf():设置缓冲
	1）无缓冲-->改文件不使用任何缓冲
	2）行缓冲-->仅对文本模式打开的文件有效，所谓行，即是指每收到一个换行符（\n或\r\n），就将缓冲flush掉
	3）全缓冲-->仅当缓冲满时才进行flush
十二章 系统调用与API
1.系统调用：应用程序与内核的接口，不同系统调用依靠系统调用号来分辨
2.Linux内核版本提供了319个系统调用：exit、fork、read、write、open、close、waitpid、creat.......
3.系统调用缺点：
	使用不便、各个操作系统之间系统调用不兼容；
4.运行库：
	使用简单、形式统一。
5.中断有两个属性，一个称为中断号（从0开始），另一个称为中断处理程序。
  中断两种类型：硬件中断（硬件异常，电脑断电、键盘被按下等），另一种称为软件中断（一条指令，int,如int 0x80触发所有的系统调用）
6.当前栈由用户栈切换为内核栈的实际行为：
	1）保存当前的ESP、SS的值
	2）将ESP、SS的值切换为内核栈的相应值
反过来，内核栈切换到用户栈：
	1）恢复原来ESP、SS的值。
	2）用户态的ESP和SS的值保存再内核栈上。
7.当0x80号中断发生时，CPU除了切入内核态之外，还会自动完成：
	1）找到当前进程的内核栈（每一个进程都有自己的内核栈），
	2）在内核栈中依次压入用户态的寄存器SS、ESP、EFLAGS、CS、EIP。
由int填充，iret恢复。










	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	