第一章 c++多线程系统编程
1.一个线程安全的class应该满足：
	1）多个线程同时访问，其表现出正确的行为，
	2）无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织，
	3）调用端代码无须额外的同步或其他协调动作。
2.对象的构造要做到线程安全，唯一的要求在构造期间不要泄露this指针：
	1）不要再构造函数中注册任何回调；
	2）也不要在构造函数中把this传给跨线程的对象；
	3）即便在构造函数的最后一行也不行。
3.shared_ptr和weak_ptr的区别：
	1）shared_ptr控制对象的生命周期。shared_ptr是强引用，只要有一个指向x对象的shared_ptr存在，该x对象 就不会析构。
	当指向对象x的最后一个shared_ptr析构或reset()的时候，x 保证会被销毁。 
	2）·weak_ptr不控制对象的生命期，但是它知道对象是否还活着（想象 成用棉线轻轻拴住堆上的对象）。如果对象还活着，
	那么它可以提升 （promote）为有效的shared_ptr；如果对象已经死了，提升会失败，返回一个空的shared_ptr。“提升／lock()”行为是线程安全的。
4.C++里可能出现的内存问题大致有这么几个方面：
	1）缓冲区溢出（buffer overrun）
	2）空悬指针／野指针 
	3）重复释放（double delete）
	4）内存泄漏（memory leak） 
	5）不配对的new[]/delete
	6）内存碎片（memory fragmentation）
5.相关解决办法：
    1）缓冲区溢出：用std::vector<char>/std::string或自己编写Buffer class来管理缓冲区，自动记住用缓冲区的长度，并通过
	成员函数而不是裸指针来修改缓冲区。 
    2）空悬指针／野指针：用shared_ptr/weak_ptr，这正是本章的主题。
	3）重复释放：用scoped_ptr，只在对象析构的时候释放一次。 
	4）内存泄漏：用scoped_ptr，对象析构的时候自动释放内存。 
	5）不配对的new[]/delete：把new[]统统替换为 std::vector/scoped_array。
6.shared_ptr的线程安全性：
	  它的引用计数本身是安全且无锁的，但对象的读写则不是，因为shared_ptr有两个数据成员，读写操作不能原子化。
7.利用weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象，从而操作资源。可以
  避免循环引用。
8.智能指针的实现：
      智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。每次创建类的新对象时，初始化
  指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象
  进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的
  引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。智能指针就是模拟指针动作的类
  。所有的智能指针都会重载 -> 和 * 操作符。智能指针还有许多其他功能，比较有用的是自动销毁。这主要是利用栈对象的有限
  作用域以及临时对象（有限作用域实现）析构函数释放内存。
9.RAII（Resource Acquisition Is Initialization）是一种利用对象生命周期来控制程序资源（如内存、文件句柄、网络连接、互斥量等等）的简单技术。 
　   RAII 的一般做法是这样的：在对象构造时获取资源，接着控制对资源的访问使之在对象的生命周期内始终保持有效，最后在对象
析构的时候释放资源。借此，我们实际上把管理一份资源的责任托管给了一个对象。这种做法有两大好处：不需要显式地释放资源。
采用这种方式，对象所需的资源在其生命期内始终保持有效。

第二章 同步精要
1.线程同步的四项原则，按重要性排列：
1）首要原则是尽量最低限度地共享对象，减少需要同步的场合。 一个对象能不暴露给别的线程就不要暴露；如果要暴露，优先考虑
 immutable对象；实在不行才暴露可修改的对象，并用同步措施来充分保护它。 
2）其次是使用高级的并发编程构件，如TaskQueue、ProducerConsumer Queue、CountDownLatch等等。 
3）最后不得已必须使用底层同步原语（primitives）时，只用非递 归的互斥器和条件变量，慎用读写锁，不要用信号量。
4）除了使用atomic整数之外，不自己编写lock-free代码3，也不要 用“内核级”同步原语45
2.对于互斥锁，建议用RAII手法封装mutex的创建、销毁、加锁、解锁这四个操作。可以避免很多问题。使用互斥锁时使用非递归（不可重入）锁：有利于排错。

第三章 多线程服务器的使用场合与常用编程模型
1.分布式系统中使用TCP长连接通信：
	1）容易定位分布式系统中的服务之间的依赖关系；
	2）通过接收和发送队列的长度也交容易定位网络和程序故障。
2.单线程的使用场合：
	1）程序可能会fork(2);
	2）限制程序的CPU占用率。
3.多线程的使用场合:提高响应速度，让IO和“计算”相互重叠，降低latency。
4.一个多线程服务程序中的线程大致可以分为3类：
	1）IO线程
	2）计算线程
	3）第三方库所用线程（log、database等）
5.Linux能同时启动多少个线程？如果是32位，大约300个
6.多线程不能提高“并发连接数”。
7.多线程不能提高计算密集型服务的吞吐量，提升的是响应速度。
8.如果设计合理，充分利用多核资源的话，能降低响应时间。
9.线程池的阻抗匹配原则:
	如果池中线程在执行任务时，密集计算所占的时间比重为P（0＜ P≤1），而系统一共有C个CPU，为了让这C个CPU跑满而又不
过载，线程池大小的经验公式T＝C/P。T是个hint，考虑到P值的估计不是很准确，T的最佳值可以上下浮动50％.这个经验公式
的原理很简单，T个线程，每个线程占用P的CPU时间，如果刚好占满C个CPU，那么必有T×P ＝C。

第四章 C++多线程系统编程精要
   1.学校多线程面临的最大的思维方式的转变：
		1）当前线程可能随时会被切换出去，或者说被抢占了；
		2）多线程程序中事件的发生顺序不再有全局统一的先后关系。
   2.线程创建需要遵循几条简单的原则：
       1）程序库不应该在未提前告知的情况下创建自己的“背景线程”。 
	   2）尽量用相同的方式创建线程，例如muduo::Thread。 
	   3）在进入main()函数之前不应该启动线程。 
	   4）程序中线程的创建最好能在初始化阶段全部完成。
   3.exit函数在c++作用中的作用除了终止进程，还会析构全局对象和已经构造完的函数静态对象。这有潜在的死锁可能
   4.避免竞争性，不要使用多个线程处理同一个描述符，并不能真正的提速。
   5.可以利用RAII技术包装文件描述符，但是要注意串话的出现，因此需要()利用shared_ptr来安全高效管理多线程网络服务程序中的并发连接
   6.如果在类对象中使用了fork()函数，会造成析构两次，出现问题，子进程不会继承父进程的内存锁、文件锁、某些定时器等
   7.在多线程中利用fork()函数，可能会造成死锁等，因为fork()只会fork当前线程的东西，不会fork其他线程，也没法办到，因此非常危险。
因此，唯一的安全做法是在fork()之后立即调用exec()执行另一个程序，彻底隔断子进程与父进程的联系。
   8.多线程信号采取统一事件源方法处理。
   
第五章 高效的多线程日志
日志记录通常要记录：
	1）收到的每条内部消息的id（还可以包括关键字段、长度、hash 等）； 
	2）收到的每条外部消息的全文5； 
	3）发出的每条消息的全文，每条消息都有全局唯一的id6； 
	4）关键内部状态的变更，等等。
日志库大体可以分为前端和后端两部分。前端是供应用程序使用的接口（API）,并生成日志消息；后端则负责把日志消息写到目的地（destination）。这两部 分的接口有可能简单到只有一个回调函数：
    muduo库针对异步写出现万一程序崩溃，那么最后若干条 日志往往就丢失了，因为日志库不能每条消息都flush硬盘，更不能每条日志都open/close文件，这样性能开销太大。muduo日志库用两个办法
	来应对这一点，其一是定期（默认3秒）将缓冲区内的日志消息flush到硬 盘；其二是每条内存中的日志消息都带有cookie（或者叫哨兵值/sentry），其值为某个函数的地址，这样通过在core dump
文件中查找 cookie17就能找到尚未来得及写入磁盘的消息。 

第六章 常见的几种并发处理模型
方案序号    并发模型       多进程   多线程   阻塞I/O  IO复用   长连接   并发性  多核  开销  互通  顺序性  线程数        特点
   0    accept+read/write   否        否      是       否       否       无     否    低    否      是      常      一次服务一个客户
   1    accept+fork         是        否      是       否       是       低     是    高    否      是      变      process-per-connection
   2    accept+thread       否        是      否       否       是       中     是    中    是      是      变      thread-per-connection
   3    poll(reactor)       否        否      否       是       是       高     否    低    是      是      常      单线程reactor
   4    reactor+thread pool 否        是      否       是       是       高     是    低    是      否      常      主线程IO，工作线程计算
   5    reactors in threads 否        是      否       是       是       高     是    低    是      是      常      one loop per thread
   6    reactors in processes是       否      否       是       是       高     是    低    否      是      常      Nginx
   7    reactors+thread pool 否       是      否       是       是       高     是    低    是      否      常      最灵活的IO与CPU配置   

第七章 muduo编程示例
   1.对于长连接的TCP服务，分包有四种方法：
     1）消息长度固定
	 2）使用特殊的字符或字符串作为消息的边界，例如HTTP协议的"\r\n"
	 3）在每条消息的头部加一个长度字段（最常见）
	 4）利用消息本身的格式来分包（例如JSON格式中的{...}的配对）
    2.Protobuf的序列化和反序列化的速度更快，而且传输的数据会先压缩，使得传输的效率更高效：
	  1）Protobuf序列化后的信息内容表示非常紧凑，减少了消息的体积，自然只需要更少的资源。比如网络上传输的字节数更少，需要的IO设备更少，从而提高性能
	  2）封建包的速度更快。
	3.使用Protobuf需要解决两个问题：
	  1）长度，Protobuf打包的数据没有自带长度信息或终结符，需要由应用程序自己在发生和接收的时候做正确的切分。 
	  2）类型，Protobuf打包的数据没有自带类型信息，需要由发送方把类型信息传给给接收方，接收方创建具体的Protobuf 
	  Message对象，再做反序列化。
	  针对问题二：根据type name反射自动创建Message对象，起关键作用的是Descriptor class，每个具体Message type对应一
	  个Descriptor对象。尽管我们没有直接调用它的函数，但是 Descriptor在“根据type name创建具体类型的Message对象”中
	  扮演了重要 的角色，起了桥梁作用
第八章 muduo网络库设计与实现


第九章 分布式系统工程实践

第十章 C++编译链接模型精要
第十二章
     1.STL中的string实现方式：
		1）无特殊处理，采取类似std::vector的数据结构（很少使用）
		2）Copy-on-Write，g++的std::string一直采用这种方式
		3）短字符优化（SSO）,利用string对象本身的空间来存储短字 符串。Visual C++用的是这种实现方式。























