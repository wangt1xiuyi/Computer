一、基本知识：

1.TCP/IP报文封装
Ethemet帧头|IP头部|TCP头部|上层数据|FCS
帧头14个字节，尾部4个字节;般IPv4的头部是20个字节。，不携带选项(option)的TCP头长为20bytes，携带选项的TCP头最长可到60bytes。

2.IP头部
版本|报头长度|服务类型|         总长度
        标识          |标志     |   段偏移量
生存期    | 协议      |         头部校验和
                源地址
               目标地址
                可选项
                 数据
解释：
    ●版本（Version）字段：占4比特。用来表明IP协议实现的版本号，当前一般为IPv4，即0100。
    ●报头长度（Internet Header Length，IHL）字段：占4比特。是头部占32比特的数字，包括可选项。普通IP数据报（没有任何选项），该字段的值是5，即160比特=20字节。
      此字段最大值为60字节。
　　●服务类型（Type of Service ，TOS）字段：占8比特。其中前3比特为优先权子字段（Precedence，现已被忽略）。第8比特保留未用。第4至第7比特分别代表延迟、吞吐量、可靠性
      和花费。当它们取值为1时分别代表要求最小时延、最大吞吐量、最高可靠性和最小费用。这4比特的服务类型中只能置其中1比特为1。可以全为0，若全为0则表示一般服务。服务类
      型字段声明了数据报被网络系统传输时可以被怎样处理。例如：TELNET协议可能要求有最小的延迟，FTP协议（数据）可能要求有最大吞吐量，SNMP协议可能要求有最高可靠性，NNTP
      （Network News Transfer Protocol，网络新闻传输协议）可能要求最小费用，而ICMP协议可能无特殊要求（4比特全为0）。实际上，大部分主机会忽略这个字段，但一些动态路由
      协议如OSPF（Open Shortest Path First Protocol）、IS-IS（Intermediate System to Intermediate System Protocol）可以根据这些字段的值进行路由决策。
    ●总长度字段：占16比特。指明整个数据报的长度（以字节为单位）。最大长度为65535字节。
    ●标志字段：占16比特。用来唯一地标识主机发送的每一份数据报。通常每发一份报文，它的值会加1。
    ●标志位字段：占3比特。标志一份数据报是否要求分段。
    ●段偏移字段：占13比特。如果一份数据报要求分段的话，此字段指明该段偏移距原始数据报开始的位置。
    ●生存期（TTL：Time to Live）字段：占8比特。用来设置数据报最多可以经过的路由器数。由发送数据的源主机设置，通常为32、64、128等。每经过一个路由器，其值减1，直到0时
      该数据报被丢弃。
    ●协议字段：占8比特。指明IP层所封装的上层协议类型，如ICMP（1）、IGMP（2） 、TCP（6）、UDP（17）等。
    ●头部校验和字段：占16比特。内容是根据IP头部计算得到的校验和码。计算方法是：对头部中每个16比特进行二进制反码求和。（和ICMP、IGMP、TCP、UDP不同，IP不对头部后的数
      据进行校验）。
    ●源IP地址、目标IP地址字段：各占32比特。用来标明发送IP数据报文的源主机地址和接收IP报文的目标主机地址。
    ●可选项字段：占32比特。用来定义一些任选项：如记录路径、时间戳等。这些选项很少被使用，同时并不是所有主机和路由器都支持这些选项。可选项字段的长度必须是32比特的整
      数倍，如果不足，必须填充0以达到此长度要求。            

3.TCP头部（20字节）：
源端口（16bit）    |      目的端口（16bit）
序号（32bit）
确认序号（32bit）
头部长度（4bit）|保留（6bit）|URG|ACK|PSH|RST|SYN|FIN|窗口大小（16bit）
校验和（16bit）    |      紧急指针（16bit）
选项
数据
解释：
    ●源、目标端口号字段：占16比特。TCP协议通过使用"端口"来标识源端和目标端的应用进程。端口号可以使用0到65535之间的任何数字。在收到服务请求时，操作系统动态地为客户端
的应用程序分配端口号。在服务器端，每种服务在"众所周知的端口"（Well-Know Port）为用户提供服务。
    ●顺序号字段：占32比特。用来标识从TCP源端向TCP目标端发送的数据字节流，它表示在这个报文段中的第一个数据字节。
    ●确认号字段：占32比特。只有ACK标志为1时，确认号字段才有效。它包含目标端所期望收到源端的下一个数据字节。
    ●头部长度字段：占4比特。给出头部占32比特的数目。没有任何选项字段的TCP头部长度为20字节；最多可以有60字节的TCP头部。
    ●标志位字段（U、A、P、R、S、F）：占6比特。各比特的含义如下：
    ◆URG：紧急指针（urgent pointer）有效。
    ◆ACK：确认序号有效。
    ◆PSH：接收方应该尽快将这个报文段交给应用层。
    ◆RST：重建连接。
    ◆SYN：发起一个连接。
    ◆FIN：释放一个连接。
    ●窗口大小字段：占16比特。此字段用来进行流量控制。单位为字节数，这个值是本机期望一次接收的字节数。
    ●TCP校验和字段：占16比特。对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，并由目标端进行验证。
    ●紧急指针字段：占16比特。它是一个偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。
    ●选项字段：占32比特。可能包括"窗口扩大因子"、"时间戳"等选项。

4.UDP头部：
源端口号（16bit)    |         目标端口号(16bit)
长度(16bit)         |         校验和(16bit)
                  数据
解释：
    ●源、目标端口号字段：占16比特。作用与TCP数据段中的端口号字段相同，用来标识源端和目标端的应用进程。
    ●长度字段：占16比特。标明UDP头部和UDP数据的总长度字节。
    ●校验和字段：占16比特。用来对UDP头部和UDP数据进行校验。和TCP不同的是，对UDP来说，此字段是可选项，而TCP数据段中的校验和字段是必须有的。

在内核中实现以上，都是利用的结构体定义，结构体中的内容就是头部内容。


二、常见知识点：
1.一个端口可以建立的连接数量没有理论上限。上限就是你的系统性能，但是受到编程无符号整型影响，接受方为65535，
发送为65535，所以总的有65535*65535

2.后退N帧协议（GBN）传输数据，是指发送方不需要在收到上一帧的ACK后才能开始发送下一帧，
而是可以连续发送帧。当接受方检测出失序的信息帧后，要求发送方重发最后一个正确接受的信息帧
之后的所有未确认的帧；或者当发送方发送了N个帧后，若发现该N个帧的前一个帧在计时器超时后仍
未返回其确认信息，则该帧被判为出错或丢失，此时发送方就不得不又重传该出错帧及随后的N个帧。
也就是说直到接收方返回确认信息之前，发送方可以一直进行数据发送，所以 发送窗口大小指的就是在接
到返回 帧之前送能发送的最大数据量。
因为发送窗口大小为1000，所以 甲在收到乙发送回来的确认 帧 之前，可以发送1000个 帧 数据 ，
而每个 帧的大小为 1000B，所以一共可以传输1000*1000B=1MB的数据。
由于单向传播延迟是50ms，从甲的第一个数据到达乙，再到甲收到乙发来的确认 帧共需2*传播时延，
即100ms=0.1s。因此其实际传输效率是1M/0.1s=10M/s, 因为 1Byte＝8bit，所以 10M/s=80Mbps。信道宽
带为100Mbps，实际为 80Mbps，类似于木桶短板理论，最大值的多少由最慢的速度决定，
所以这里取二者最小值，即 80Mbps。
如果主机想访问本地局域网外的某一网络，需要做两件事：

3.设置本机的默认网关。本地局域网默认网关上需要设置一条路由，用以完成本地局域网内的任一主机到
目标局域网主机的路由工作。

4.ping命令用来检测两部主机之间的传输信道是否畅通，或远程主机是否正常
  route命令用来显示目前本机路由表的内容，并且还可以针对路由表中的记录来进行相应的添加、删除或
  修改等操作。
  traceroute命令用来探测路由经过
  ifconfig命令用来来检测和设置本机的网络接口。

5.这样的变长数组（柔性数组）常用于网络通信中构造不定长数据包，不会浪费空间浪费网络流量，比如我要发送1024字节的数据，
如果用定长包，假设定长包的长度为2048，就会浪费1024个字节的空间，也会造成不必要的流量浪费

6.read与write系统调用缓冲问题

1）首先，write成功返回，只是buf中的数据被复制到了kernel中的TCP发送缓冲区，至于数据什么时候被发往网络，什么时候被对方主机接收，什么时候被对方进程读取，系统调用层面不会给予任何保证和通知。
write在什么情况下会阻塞？当kernel的该socket的发送缓冲区已满时。对于每个socket，拥有自己的send buffer和receive buffer。从Linux 2.6开始，两个缓冲区大小都由系统来自动调节（autotuning），
但一般在default和max之间浮动。已经发送到网络的数据依然需要暂存在send buffer中，只有收到对方的ack后，kernel才从buffer中清除这一部分数据，为后续发送数据腾出空间。接收端将收到的数据暂存
在receive buffer中，自动进行确认。但如果socket所在的进程不及时将数据从receive buffer中取出，最终导致receive buffer填满，由于TCP的滑动窗口和拥塞控制，接收端会阻止发送端向其发送数据。
这些控制皆发生在TCP/IP栈中，对应用程序是透明的，应用程序继续发送数据，最终导致send buffer填满，write调用阻塞。一般来说，由于接收端进程从socket读数据的速度跟不上发送端进程向socket写
数据的速度，最终导致发送端write调用阻塞。而read调用的行为相对容易理解，从socket的receive buffer中拷贝数据到应用程序的buffer中。read调用阻塞，通常是发送端的数据没有到达。

2）read总是在接收缓冲区有数据时立即返回，而不是等到给定的read buffer填满时返回。
只有当receive buffer为空时，blocking模式才会等待，而nonblock模式下会立即返回-1（errno = EAGAIN或EWOULDBLOCK）

3）blocking的write只有在缓冲区足以放下整个buffer时才返回（与blocking read并不相同）
nonblock write则是返回能够放下的字节数，之后调用则返回-1（errno = EAGAIN或EWOULDBLOCK）
对于blocking的write有个特例：当write正阻塞等待时对面关闭了socket，则write则会立即将剩余缓冲区填满并返回所写的字节数，再次调用则write失败（connection reset by peer），

4）假设A机器上的一个进程a正在和B机器上的进程b通信：某一时刻a正阻塞在socket的read调用上（或者在nonblock下轮询socket）
当b进程终止时，无论应用程序是否显式关闭了socket（OS会负责在进程结束时关闭所有的文件描述符，对于socket，则会发送一个FIN包到对面）。
”同步通知“：进程a对已经收到FIN的socket调用read，如果已经读完了receive buffer的剩余字节，则会返回EOF:0
”异步通知“：如果进程a正阻塞在read调用上（前面已经提到，此时receive buffer一定为空，因为read在receive buffer有内容时就会返回），则read调用立即返回EOF，进程a被唤醒。
socket在收到FIN后，虽然调用read会返回EOF，但进程a依然可以其调用write，因为根据TCP协议，收到对方的FIN包只意味着对方不会再发送任何消息。 在一个双方正常关闭的流程中，
收到FIN包的一端将剩余数据发送给对面（通过一次或多次write），然后关闭socket。

5）但是事情远远没有想象中简单。优雅地（gracefully)关闭一个TCP连接，不仅仅需要双方的应用程序遵守约定，中间还不能出任何差错。
假如b进程是异常终止的，发送FIN包是OS代劳的，b进程已经不复存在，当机器再次收到该socket的消息时，会回应RST（因为拥有该socket的进程已经终止）。a进程对收到RST的socket调
用write时，操作系统会给a进程发送SIGPIPE，默认处理动作是终止进程，知道你的进程为什么毫无征兆地死亡了吧：）
通过以上的叙述，内核通过socket的read/write将双方的连接异常通知到应用层，虽然很不直观，似乎也够用。
这里说一句题外话：
不知道有没有同学会和我有一样的感慨：在写TCP/IP通信时，似乎没怎么考虑连接的终止或错误，只是在read/write错误返回时关闭socket，程序似乎也能正常运行，但某些情况下总是会
出奇怪的问题。想完美处理各种错误，却发现怎么也做不对。原因之一是：socket（或者说TCP/IP栈本身）对错误的反馈能力是有限的。
参考网址：https://www.cnblogs.com/junneyang/p/6126635.html

6）考虑这样的错误情况：
不同于b进程退出（此时OS会负责为所有打开的socket发送FIN包），当B机器的OS崩溃（注意不同于人为关机，因为关机时所有进程的退出动作依然能够得到保证）/主机断电/网络不可达时，
a进程根本不会收到FIN包作为连接终止的提示。如果a进程阻塞在read上，那么结果只能是永远的等待。如果a进程先write然后阻塞在read，由于收不到B机器TCP/IP栈的ack，TCP会持续重
传12次（时间跨度大约为9分钟），然后在阻塞的read调用上返回错误：ETIMEDOUT/EHOSTUNREACH/ENETUNREACH假如B机器恰好在某个时候恢复和A机器的通路，并收到a某个重传的pack，因为
不能识别所以会返回一个RST，此时a进程上阻塞的read调用会返回错误ECONNREST。恩，socket对这些错误还是有一定的反馈能力的，前提是在对面不可达时你依然做了一次write调用，而不
是轮询或是阻塞在read上，那么总是会在重传的周期内检测出错误。如果没有那次write调用，应用层永远不会收到连接错误的通知。write的错误最终通过read来通知应用层，有点阴差阳错？

7）至此，我们知道了仅仅通过read/write来检测异常情况是不靠谱的，还需要一些额外的工作：假如利用TCP的keepalive功能来加强处理非活跃连接，或者太久未回应的连接：
cat /proc/sys/net/ipv4/tcp_keepalive_time
7200
cat /proc/sys/net/ipv4/tcp_keepalive_intvl
75
cat /proc/sys/net/ipv4/tcp_keepalive_probes
9

意思是keepalive routine每2小时（7200秒）启动一次，发送第一个probe（探测包），如果在75秒内没有收到对方应答则重发probe，当连续9个probe没有被应答时，认为连接已断
但在我印象中keepalive不太好用，默认的时间间隔太长，又是整个TCP/IP栈的全局参数：修改会影响其他进程；主流可以参考进行应用层的心跳检测。

7.RST详解
在TCP协议中RST表示复位，用来异常的关闭连接，在TCP的设计中它是不可或缺的。发送RST包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓存区的包发送RST包。而接收端收到RST包后，
也不必发送ACK包来确认。其实在网络编程过程中，各种RST错误其实是比较难排查和找到原因的。下面我列出几种会出现RST的情况。
1）端口未打卡：服务器程序端口未打开而客户端来连接。
2）请求超时
3）提前关闭
4）在一个已关闭的socket上收到数据
参考网址：https://www.cnblogs.com/hongbing/p/4076965.html

8.RST攻击
A和服务器B之间建立了TCP连接，此时C伪造了一个TCP包发给B，使B异常的断开了与A之间的TCP连接，就是RST攻击了。实际上从上面RST标志位的功能已经可以看出这种攻击如何达到效果了。
那么伪造什么样的TCP包可以达成目的呢？我们至顶向下的看。假定C伪装成A发过去的包，这个包如果是RST包的话，毫无疑问，B将会丢弃与A的缓冲区上所有数据，强制关掉连接。
如果发过去的包是SYN包，那么，B会表示A已经发疯了（与OS的实现有关），正常连接时又来建新连接，B主动向A发个RST包，并在自己这端强制关掉连接。
这两种方式都能够达到复位攻击的效果。似乎挺恐怖，然而关键是，如何能伪造成A发给B的包呢？这里有两个关键因素，源端口和序列号。
一个TCP连接都是四元组，由源IP、源端口、目标IP、目标端口唯一确定一个连接。所以，如果C要伪造A发给B的包，要在上面提到的IP头和TCP头，把源IP、源端口、目标IP、目标端口都填
对。这里B作为服务器，IP和端口是公开的，A是我们要下手的目标，IP当然知道，但A的源端口就不清楚了，因为这可能是A随机生成的。当然，如果能够对常见的OS如windows和linux找出
生成source port规律的话，还是可以搞定的。

序列号问题是与滑动窗口对应的，伪造的TCP包里需要填序列号，如果序列号的值不在A之前向B发送时B的滑动窗口内，B是会主动丢弃的。所以我们要找到能落到当时的AB间滑动窗口的序列
号。这个可以暴力解决，因为一个sequence长度是32位，取值范围0-4294967296，如果窗口大小像上图中我抓到的windows下的65535的话，只需要相除，就知道最多只需要发65537（4294967296/65535=65537）
个包就能有一个序列号落到滑动窗口内。RST包是很小的，IP头＋TCP头也才40字节，算算我们的带宽就知道这实在只需要几秒钟就能搞定。那么，序列号不是问题，源端口会麻烦点，如果各
个操作系统不能完全随机的生成源端口，或者黑客们能通过其他方式获取到source port，RST攻击易如反掌，后果很严重。


9.TCP滑动窗口、流量控制原理
1）首先是第一次发送数据这个时候的窗口大小是根据链路带宽的大小来决定的；首先是第一次发送数据这个时候的窗口大小是根据链路带宽的大小来决定的。我们假设这个时候窗口的大小
是3。这个时候接受方收到数据以后会对数据进行确认告诉发送方我下次希望手到的是数据是多少。这里我们看到接收方发送的ACK=3(这是发送方发送序列2的回答确认，下一次接收方期望
接收到的是3序列信号)。这个时候发送方收到这个数据以后就知道我第一次发送的3个数据对方只收到了2个。就知道第3个数据对方没有收到。下次在发送的时候就从第3个数据开始发。
这个时候窗口大小就变成了2 。 
2）滑动窗口协议，是TCP使用的一种流量控制方法。该协议允许发送方在停止并等待确认前可以连续发送多个分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数
据的传输。只有在接收窗口向前滑动时（与此同时也发送了确认），发送窗口才有可能向前滑动。收发两端的窗口按照以上规律不断地向前滑动，因此这种协议又称为滑动窗口协议。当发
送窗口和接收窗口的大小都等于1时，就是停止等待协议。

10.TCP拥塞控制原理
1）发生拥塞控制的原因：资源(带宽、交换节点的缓存、处理机)的需求>可用资源。
2）拥塞控制就是为了防止过多的数据注入到网络中，这样可以使网络中的路由器或者链路不至于过载。拥塞控制要做的都有一个前提：就是网络能够承受现有的网络负荷。
3）发送方为一个动态变化的窗口叫做拥塞窗口，拥塞窗口的大小取决于网络的拥塞程度。发送方让自己的发送窗口=拥塞窗口，但是发送窗口不是一直等于拥塞窗口的，在网络情况好的时
候，拥塞窗口不断的增加，发送方的窗口自然也随着增加，但是接受方的接受能力有限，在发送方的窗口达到某个大小时就不在发生变化了。
4）发送方如果知道网络拥塞了呢？发送方发送一些报文段时，如果发送方没有在时间间隔内收到接收方的确认报文段，则就可以人为网络出现了拥塞。
5）慢启动算法的思路：主机开发发送数据报时，如果立即将大量的数据注入到网络中，可能会出现网络的拥塞。慢启动算法就是在主机刚开始发送数据报的时候先探测一下网络的状况，
如果网络状况良好，发送方每发送一次文段都能正确的接受确认报文段。那么就从小到大的增加拥塞窗口的大小，即增加发送窗口的大小。
6）拥塞避免：为了防止cwnd增加过快而导致网络拥塞，所以需要设置一个慢开始门限ssthresh状态变量（我也不知道这个到底是什么，就认为他是一个拥塞控制的标识）,它的用法：
i.当cwnd < ssthresh,使用慢启动算法，
ii.当cwnd > ssthresh,使用拥塞控制算法，停用慢启动算法。
iii.当cwnd = ssthresh，这两个算法都可以。
拥塞避免的思路：是让cwnd缓慢的增加而不是加倍的增长，每经历过一次往返时间就使cwnd增加1，而不是加倍，这样使cwnd缓慢的增长，比慢启动要慢的多。
7）无论是慢启动算法还是拥塞避免算法，只要判断网络出现拥塞，就要把慢启动开始门限(ssthresh)设置为设置为发送窗口的一半（>=2），cwnd(拥塞窗口)设置为1，然后在使用慢
启动算法，这样做的目的能迅速的减少主机向网络中传输数据，使发生拥塞的路由器能够把队列中堆积的分组处理完毕。拥塞窗口是按照线性的规律增长，比慢启动算法拥塞窗口增
长块的多。
8）AIMD(加法增大乘法减小)
i.乘法减小：无论在慢启动阶段还是在拥塞控制阶段，只要网络出现超时，就是将cwnd置为1，ssthresh置为cwnd的一半，然后开始执行慢启动算法（cwnd<ssthresh）。
ii.加法增大：当网络频发出现超时情况时，ssthresh就下降的很快，为了减少注入到网络中的分组数，而加法增大是指执行拥塞避免算法后，是拥塞窗口缓慢的增大，以防止网络过早出
现拥塞。
9）快重传算法要求首先接收方收到一个失序的报文段后就立刻发出重复确认，而不要等待自己发送数据时才进行捎带确认。接收方成功的接受了发送方发送来的M1、M2并且分别给发送
了ACK，现在接收方没有收到M3，而接收到了M4，显然接收方不能确认M4，因为M4是失序的报文段。如果根据可靠性传输原理接收方什么都不做，但是按照快速重传算法，在收到M4、M5
等报文段的时候，不断重复的向发送方发送M2的ACK,如果接收方一连收到三个重复的ACK,那么发送方不必等待重传计时器到期，由于发送方尽早重传未被确认的报文段。
10）快恢复
i.当发送发连续接收到三个确认时，就执行乘法减小算法，把慢启动开始门限（ssthresh）减半，但是接下来并不执行慢开始算法。
ii.此时不执行慢启动算法，而是把cwnd设置为ssthresh的一半， 然后执行拥塞避免算法，使拥塞窗口缓慢增大

11.为什么不能用两次握手进行连接？
我们知道，3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。
    现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手
的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己
的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

12.ICMP协议
   八位类型     | 八位代码   |  16位校验和
八位类型：区分报文类型-->一类是差错报文（主要用来回应网络错误，比如目标不可达（类型值为3）和重定向（类型值为5）），一类是查询报文（查询网络信息）





















































































