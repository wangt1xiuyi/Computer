一、Map-Reduce
1.Map阶段 --->把大任务分成子任务（哈希函数）
2.Reduce阶段 --->子任务并发处理，然后合并结果
注意点：1.备份的考虑，分布式存储的设计细节以及容灾策略
        2.任务分配策略与任务进度跟踪的细节设计、节点状态的呈现
        3.多用户权限的控制
3.用map-reduce方法统计一篇文章中每个单词出现的个数

首先处理单词形成只有单词文本，然后对每个单词生成词频为1的记录，然后通过哈希函数得到每个单词的
哈希值，并根据该值分成若干组任务，子任务合并相同的单词，最后返回处理合并

4.常见海量处理题目解题关键：
1）分而治之，通过哈希函数将大任务分流到机器，或分流成小文件。常用hashmap或bitmap。

5。对十亿个ip地址排序。
利用bitmp只需要512M左右，而不用需要4G。

6.大年龄排序
因为年龄不超过200，因此只要200的一个数组

7.有一个包含20亿个全是32位整数的大文件，在其中找到出现次数最多的数，但是内存限制只有2G。
7.1)hashmap记录所有出现的次数。（可能会超出，需要1.6G）
7.2)20亿个32位整数进行分流（利用哈希函数进行分流16个小文件，找到其中最多的，然后再比较16个第一
从而确定最多的整数）。

8. 在一个32位无符号整数范围中（约40亿）中找到未出现过的数，最多使用10M内存。如何找
把0-2^32-1范围分成64个区间，单个区间装2^32/64个数，总共的范围为42亿，但数一共为40亿，必然会有区间计数不足。
此时只对区间a上的数，用bitmap统计。只需8m左右空间。

9.找出100亿词中最多的前100个词
1）.使用哈希函数进行分流（依据内存、硬盘等分配）
2）.如果不够用，再进行一次分流，处理每一个小文件，得到每个小文件词汇的词频统计建立记录后，利用小根堆来进行TOP100的筛选。
3）.继续外排序或小根堆继续合并

10.工程师常用服务器集群来设计和实现数据缓存，常见策略：1）无论是添加、查询还是删除数据，都先将数据
的id通过哈希函数转换成一个哈希值，记为key。2）如果目前机器有N台，则计算key%N的值，这个值就是该数据
所属的机器编号，无论是添加、删除还是查询操作，都只在这台机器上进行。请分析这种策略缓存可能带来的问题
，并提出改进的方案。
潜在问题：如果增加或删除机器时，代价很高，所有数据都要迁移，因为%运算失效，需要重新计算哈希值。
改进：一致性哈希算法。机器哈希值首尾相连，数据id顺时针寻找最近的机器。

二、bitmap(位图法)
1.求十进制0-N对应在数组a中的下标： 
十进制0-31，对应在a[0]中，先由十进制数n转换为与32的余可转化为对应在数组a中的下标。比如n=24,那么 n/32=0，则24对应在数组a中的下标为0。又比如n=60,那么n/32=1，则60对应在数组a中的下标为1，同理可以计算0-N在数组a中的下标。 

2.求0-N对应0-31中的数： 
十进制0-31就对应0-31，而32-63则对应也是0-31，即给定一个数n可以通过模32求得对应0-31中的数。 

3.利用移位0-31使得对应32bit位为1. 
#include <iostream>    
#define N 10000000
#define SHIFT 5
using namespace std;
//申请空间
int a[1 + N / 32];
void set(int i) {
	a[i >> SHIFT] |= 1 << (i & 0x1F);
}
void clr(int i) {
	a[i >> SHIFT] &= ~1 << (i & 0x1F);
}
bool test(int i) {
	return a[i >> SHIFT] & 1 << (i & 0x1F);
}
int main()
{
	set(23);
	set(100000);
	cout << test(100) << endl;
	cout << test(1000) << endl;
	clr(100);
	cout << test(100000) << endl;
}
i>>SHIFT： 
其中SHIFT=5，即i右移5为，2^5=32,相当于i/32，即求出十进制i对应在数组a中的下标。比如i=20，通过i>>SHIFT=20>>5=0 可求得i=20的下标为0； 
i & MASK： 
其中MASK=0X1F,十六进制转化为十进制为31，二进制为0001 1111，i&（0001 1111）相当于保留i的后5位。 
比如i=23，二进制为：0001 0111，那么 
                         0001 0111 
                   &    0001 1111 = 0001 0111 十进制为：23 
比如i=83，二进制为：0000 0000 0101 0011，那么 
                          0000 0000 0101 0011 
                     &   0000 0000 0001 0000 = 0000 0000 0001 0011 十进制为：19 
i & MASK相当于i%32。 
1<<(i & MASK) 
相当于把1左移 (i & MASK)位。 
比如(i & MASK)=20，那么i<<20就相当于： 
   0000 0000 0000 0000 0000 0000 0000 0001 >>20 
      =0000 0000 0000 1000 0000 0000 0000 0000 
升级：
例：5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。
将bit-map扩展一下，用2bit表示一个数即可，0表示未出现，1表示出现一次，2表示出现2次及以上，在遍历这些数的时候，如果对应位置的值是0，
则将其置为1；如果是1，将其置为2；如果是2，则保持不变。或者我们不用2bit来进行表示，我们用两个bit-map即可模拟实现这个 2bit-map，都是一样的道理。

三、哈希算法（MD5、SHA1算法）
解决哈希冲突：拉链法、开地址法
MD5算法：https://blog.csdn.net/xiaofengcanyuexj/article/details/37698801
计算步骤：
         MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。
第一步、填充

      如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余的结果等于448。填充的方法是填充一个1和n个0。填充完后，信息的长度就为N*512+448(bit)；

第二步、记录信息长度

     用64位来存储填充前信息长度。这64位加在第一步结果的后面，这样信息长度就变为N*512+448+64=(N+1)*512位。

第三步、装入标准的幻数（四个整数）

     标准的幻数（物理顺序）是（A=(01234567)16，B=(89ABCDEF)16，C=(FEDCBA98)16，D=(76543210)16）。如果在程序中定义应该是（A=0X67452301L，B=0XEFCDAB89L，C=0X98BADCFEL，D=0X10325476L）。有点晕哈，其实想一想就明白了。

第四步、四轮循环运算

     循环的次数是分组的个数（N+1）

   1）将每一512字节细分成16个小组，每个小组64位（8个字节）    
   2）先认识四个线性函数(&是与,|是或,~是非,^是异或) 
   3）设Mj表示消息的第j个子分组（从0到15），<<<s表示循环左移s位，则四种操作为：
   4）四轮运算   
   5）每轮循环后，将A，B，C，D分别加上a，b，c，d，然后进入下一循环。
四、一致性哈希算法

